
import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.LineNumberReader;
import java.io.PrintWriter;

public class TextFile extends File {

private static final long serialVersionUID = 5447032761953485418L;


    public TextFile(String path) {
        super(path);
        //this(path,false);
    }

    public TextFile(String path, boolean makedirs) {
        super(path);
        if (makedirs) getParentFile().mkdirs();
    }

    public boolean println(String str) {
        return println(str, true);
    }

    public boolean println(String str, boolean append) {
        PrintWriter out = null;
        try {
            out = new PrintWriter(new FileWriter(this, append), append);
            if (out != null)
                out.println(str);
        } catch (IOException e) {
            System.err.println("ERROR: " + e.getMessage() + " at " + e.getClass());
        } finally {
            if (out != null) out.close();
        }
        return !out.checkError();
    }

    public boolean print(String str) {
        return print(str, true);
    }

    public boolean print(String str, boolean append) {
        boolean retVal = false;
        PrintWriter out = null;

        try {
            out = new PrintWriter(new FileWriter(this, append), append);
            if (out != null) {
                retVal = !out.checkError();
                out.print(str);
            }
        } catch (IOException e) {
            System.out.println("ERROR: " + e.getMessage() + " at " + e.getClass());
        } finally {
            if (out != null) out.close();
        }
        return retVal;
    }

    public LineNumberReader getLineNumberReader() throws FileNotFoundException {
        return new LineNumberReader(new FileReader(this));
    }

    public BufferedReader getBufferedReader() throws FileNotFoundException {
        return new BufferedReader(new FileReader(this));
    }

    public FileReader getFileReader() throws FileNotFoundException {
        return new FileReader(this);
    }

/*
    public String readLine(){
        LineNumberReader reader = null;
        String line = null;
        try {
            reader = new LineNumberReader(new FileReader(this));
            line = reader.readLine();
        } catch (FileNotFoundException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        } catch (IOException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        } finally {
            try {
                if (reader != null ) reader.close();
            } catch (IOException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            }
        }

        return line;
    }
*/

    public String getContent() {
        FileInputStream fis = null;
        String str = null;
        try {
            fis = new FileInputStream(this);
            int size = fis.available();
            byte[] bytes = new byte[size];
            fis.read(bytes);
            str = new String(bytes);
        } catch (IOException e) {
            e.printStackTrace();  //To change body of catch statement use File | Settings | File Templates.
        } finally {
            try {
                fis.close();
            } catch (IOException e) {
            }
        }
        return str;
    }

    public static void main(String[] args) {
        String path = "c:/1/2/3/Test.txt";
        TextFile txt = new TextFile(path, true);
        //TextFile txt = new TextFile("c:/1/2/3/Test.txt");

        txt.println("Text File test!", false);//Overwrite (do not append)
        txt.println("Appended line!");//append line
        txt.print("--------------");//append line

        System.out.println(new TextFile(path).getContent());
        try {
            LineNumberReader reader = txt.getLineNumberReader();
            int lineNum = 4;
            reader.setLineNumber(lineNum);
            String line = reader.readLine();

            //Always reads first line regardles
            //which line number has been set!!!!!!!!!!!!!!!!!
            System.out.println("Line (" + lineNum + ") : " + line);
            reader.close();
        } catch (FileNotFoundException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        } catch (IOException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }

    }
}

///////////////////////////////////////////////////////////////////
//NodeIterator//////////////////////////////////////////////////////
package com.jcocktail.utils.xml.dom;

import org.w3c.dom.Node;
import org.w3c.dom.NodeList;

// Depth first search of DOM Tree

public abstract class NodeIterator {
    int level = 0;

    // note use of recursion
    public void followNode(Node node) throws Exception {

        processNode(node);
        if (node.hasChildNodes()) {
            NodeList children = node.getChildNodes();
            for (int i = 0; i < children.getLength(); i++) {
                level++;
                followNode(children.item(i));
                level--;
            }
        }
        postProcessNode(node);

    }

    public int getLevel() {
        return level;
    }

    // Override this method to do something as each node is visited
    protected abstract void processNode(Node node) throws Exception;

    // I could make processNode() a separate method in
    // a NodeProcessor interface, and make followNode static
    // but I wanted to keep this example simple.
    protected abstract void postProcessNode(Node node) throws Exception;

}

//DOMPrinter/////////////////////////////////////////////////////////////////

import java.io.IOException;
import java.io.Writer;

import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.NamedNodeMap;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;

public class DOMPrinter extends NodeIterator{
	
	private Writer out;
	private String encoding = "UTF-8";
	private String lineSeparator = System.getProperty("line.separator");
	private boolean printDeclaration = true;
	private String identStr = "\t";
	
	public DOMPrinter() {
		super();
	}
	
	public DOMPrinter(Writer out) {
		super();
		this.out = out;
	}

	public String getEncoding() {
		return encoding;
	}

	public void setEncoding(String encoding) {
		this.encoding = encoding;
	}

	public boolean isPrintDeclaration() {
		return printDeclaration;
	}

	public void setPrintDeclaration(boolean printDeclaration) {
		this.printDeclaration = printDeclaration;
	}
	
	public String getIdentStr() {
		return identStr;
	}

	public void setIdentStr(String identStr) {
		this.identStr = identStr;
	}

	public String getLineSeparator() {
		return lineSeparator;
	}

	public void setLineSeparator(String lineSeparator) {
		this.lineSeparator = lineSeparator;
	}

	public void write(Writer out, Node node) throws Exception{
		if(node.getNodeType() == Node.DOCUMENT_NODE){			
			node = ((Document)node).getDocumentElement();			
		}
			
		this.out = out;
		if(printDeclaration) write("<?xml version=\"1.0\" encoding=\"" + encoding + "\"?>");
		followNode(node);
	}
	
	public String getIdent(String identVal) {
        int i = getLevel();
        StringBuffer sb = new StringBuffer("");
        while (i-- > 0) sb.append(identVal);
        return sb.toString();
    }
	
	private void write(String str) throws IOException{
		out.write(new String(str.getBytes(),encoding));		
	}
	
	public String attributesToString(Element element) {
        String retVal = "";
        NamedNodeMap attrMap = element.getAttributes();
        for (int i = 0; i < attrMap.getLength(); i++) {
            Node attr = attrMap.item(i);
            String attrName = attr.getNodeName();
            String attrValue = element.getAttribute(attrName);
            retVal = retVal + " " + attrName + "=\"" + attrValue + "\"";
        }
        return retVal;
    }
	
	public String getCDATA(Element element) {
        String txt = "";

        if (element.hasChildNodes()) {
            NodeList childNodes = element.getChildNodes();

            if (childNodes != null) {
                for (int j = 0; j < childNodes.getLength(); j++) {
                    if (childNodes.item(j) != null && childNodes.item(j).getNodeType() == Node.CDATA_SECTION_NODE) {
                        txt += childNodes.item(j).getNodeValue();
                    }
                }
            }
        }
        //else return null;
        return txt;
    }
	
	public String getTextContent(Element element) {
        String txt = "";

        if (element.hasChildNodes()) {
            NodeList childNodes = element.getChildNodes();

            if (childNodes != null) {
                for (int j = 0; j < childNodes.getLength(); j++) {
                    if (childNodes.item(j) != null && childNodes.item(j).getNodeType() == Node.TEXT_NODE) {
                        txt +=  childNodes.item(j).getNodeValue();
                    }
                }
            }
        }
        /* Replace XML special characters...
	    1.  & - &amp;
			2. < - &lt;
			3. > - &gt;
			4. " - &quot;
			5. ' - &#39; 
			
         */
        return txt.
        	replaceAll("&", "&amp;").
			replaceAll("<", "&lt;").
			replaceAll(">", "&gt;").							
			replaceAll("\"", "&quot;").
			replaceAll("'", "&#39;");
			
    }
	
	protected void processNode(Node node) throws Exception {	
		
		if(node.getNodeType() == Node.COMMENT_NODE){
			write(getIdent(identStr));
			write("<!-- ");
			write(node.getNodeValue());
			write(" -->".concat(lineSeparator));
			return;
		}
		if(node.getNodeType() != Node.ELEMENT_NODE) return;
				
		//Do not write a new line separator if 'out' is empty
		if(out.toString().trim().length()>0)write(lineSeparator);
		
		write(getIdent(identStr));
		write("<");
		write(node.getNodeName());
		
		String attributes = attributesToString((Element)node);
		if(!"".equals(attributes.trim())) write(" ");
		write(attributes);
		if (node.hasChildNodes()){
			write(">");	
			
			String text = getTextContent((Element)node);
			
			if (!"".equals(text.trim())){				
				write(text);				
			}			
			
			String cdata = getCDATA((Element)node).trim();
			if (!"".equals(cdata)){
//				write(getIdent(identStr));
				write("<![CDATA[");
				write(cdata);
				write("]]>");
			}						
		}
		else{
			write("/>");
		}
		out.flush();
		
	}

	protected void postProcessNode(Node node) throws Exception {
		if(node.getNodeType() != Node.ELEMENT_NODE) return;
		ElementAdapter ea = new ElementAdapter((Element)node);
		if (ea.getElement().hasChildNodes()){
			if ("".equals(ea.getTextAndCDATA().trim())){
				write(lineSeparator.concat(getIdent(identStr)));
			}
			write("</");
			write(ea.getElementName());
			write(">");
		}	
		out.flush();		
	}
	
	public static void main(String[] args) throws Exception {
		java.io.StringWriter w = new java.io.StringWriter();
		DOMPrinter dw = new DOMPrinter(w);
		dw.setPrintDeclaration(false);
		Document d = BasicDom.parseXml("<root>\n" +
				"\t<firstChild attrib1=\"ATTRIB1\">TEXT1--</firstChild>" +
				"<secondChild >TTTasdf\n<![CDATA[**sdfsdf**]]>sdasdfsdaf</secondChild>" +
				"</root>", null, false);
		dw.write(w,d);
		System.out.println(w);
	}
}
//BasicDom//////////////////////////////////////////////////////////////////

import java.io.File;
import java.io.IOException;
import java.io.StringReader;
import java.io.StringWriter;
import java.io.Writer;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.transform.Result;
import javax.xml.transform.Source;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerConfigurationException;
import javax.xml.transform.TransformerException;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;

import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.xml.sax.InputSource;
import org.xml.sax.SAXException;

import com.jcocktail.utils.data.Table;
import com.jcocktail.utils.data.TableUtils;

public class BasicDom {

    // Parses an XML file and returns a DOM document.
    // If validating is true, the contents is validated against the DTD
    // specified in the file.
    public static synchronized Document parseXmlFile(String filename, boolean validating) throws ParserConfigurationException, IOException, SAXException {
        //try {
        // Create a builder factory
        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
        factory.setValidating(validating);

        // Create the builder and parse the file
        Document doc = factory.newDocumentBuilder().parse(new File(filename));
        return doc;
        //} catch (SAXException e) {
        // A parsing error occurred; the xml input is not valid
        //} catch (ParserConfigurationException e) {
        //} catch (IOException e) {
        //}
        //return null;
    }

    /**
     * @param s
     * @param systemId
     * @param validating
     * @return
     */
    public static synchronized Document parseXml(String s, String systemId, boolean validating) {
        InputSource is = new InputSource();
        is.setCharacterStream(new StringReader(s));

        if (systemId != null || "".equals(systemId)) is.setSystemId(systemId);

        try {

            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
            DocumentBuilder builder = factory.newDocumentBuilder();
            factory.setValidating(validating);

            Document doc = builder.parse(is);
            return doc;
        } catch (SAXException sxe) {
            // Error generated during parsing)
            Exception x = sxe;
            if (sxe.getException() != null)
                x = sxe.getException();
            x.printStackTrace();

        } catch (ParserConfigurationException pce) {
            // Parser with specified options can't be built
            pce.printStackTrace();

        } catch (IOException ioe) {
            // I/O error
            ioe.printStackTrace();
        }
        return null;
    }

    public static String writeXml(Document doc) {
    	String xml = null;
    	StringWriter out = new StringWriter();
    	writeXml(doc,new StreamResult(new StringWriter()));
    	xml = out.toString();
    	return xml;
    }
    
//  This method writes a DOM document to a file
    public static void writeXml(Document doc, Writer writer) {
    	writeXml(doc,new StreamResult(writer));
    }
    
    //  This method writes a DOM document to a file
    public static void writeXml(Document doc, File file) {
    	writeXml(doc,new StreamResult(file));
    }
    
    public static void writeXml(Document doc, Result result) {
        try {
            // Prepare the DOM document for writing
            Source source = new DOMSource(doc);
            // Write the DOM document to the file
            Transformer xformer = TransformerFactory.newInstance().newTransformer();
            xformer.transform(source, result);
        } catch (TransformerConfigurationException e) {
        } catch (TransformerException e) {
        }
    }

    //TODO: This method is in development. Don't use it!!!
    public static synchronized Document loadFromTable(Table elements, Table attributes) {
        try {

            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
            DocumentBuilder builder = factory.newDocumentBuilder();

            Document doc = builder.newDocument();
            Element item = iterateElementTableRows(doc, null, elements, attributes);

            System.out.println("element = " + item);
            doc.appendChild(item);
//            try {
//                Element element = null;
//                for (int i = 0; i < elements.getRowCount(); i++) {
//                    String elementId = elements.getString("ELEMENT_ID", i);
//                    String elementName = elements.getString("ELEMENT_NAME", i);
//                    String elementText = elements.getString("ELEMENT_TEXT", i);
//                    String elementParentId = elements.getString("ELEMENT_PARENT_ID", i);
//
//                    element = doc.createElement(elementName);
//
//                    Table childElements = getChildElements(elements, elementId);
//                    if (childElements != null) {
//                        for (int k = 0; k < childElements.getRowCount(); k++) {
//                            Node n = element.appendChild(doc.createElement(childElements.getString("ELEMENT_NAME", k)));
//
//                        }
//                    }
//
//                    System.out.println("childElements = " + childElements);
////                    while ((childElements = getChildElements(childElements, elementParentId)) != null){
////                        System.out.println("childElements = " + childElements);
////                    }
//
//                    element.appendChild(doc.createTextNode(elementText));
//
//                    Table attribs = TableUtils.select(attributeTable,
//                            new String[]{"ELEMENT_ID", "ATTRIB_NAME", "ATTRIB_VALUE"},
//                            new String[]{"ELEMENT_ID=" + elementId});
//
//                    if (attribs != null) {
//                        for (int j = 0; j < attribs.getRowCount(); j++) {
//                            String name = attribs.getString("ATTRIB_NAME", j);
//                            String value = attribs.getString("ATTRIB_VALUE", j);
//                            element.setAttribute(name, value);
//                        }
//                    }
//                }
//                Element menu = doc.createElement("menu");
//                menu.appendChild(element);
//                doc.appendChild(menu);
//
//            } catch (Exception e) {
//                e.printStackTrace();  //To change body of catch statement use File | Settings | File Templates.
//            }


            return doc;

        } catch (ParserConfigurationException pce) {
            // Parser with specified options can't be built
            pce.printStackTrace();

        }
        return null;
    }

    private static synchronized Element iterateElementTableRows(Document doc, Element item, Table elements, Table attributes) {
        try {
            if (elements != null) {
                for (int i = 0; i < elements.getRowCount(); i++) {
                    String elementId = elements.getString("ELEMENT_ID", i);
                    String elementName = elements.getString("ELEMENT_NAME", i);
                    String elementText = elements.getString("ELEMENT_TEXT", i);
                    String elementParentId = elements.getString("ELEMENT_PARENT_ID", i);
                    System.out.println("elementId = " + elementId);
                    Table childElements = getChildElements(elements, elementId);
                    if (item == null) {
                        item = doc.createElement(elementName);

                    } else {
                        item.appendChild(doc.createElement(elementName));
                    }

                    //Append Text Node
                    item.appendChild(doc.createTextNode(elementText));

                    //Add Attributes
                    Table attribs = getElementAttributes(attributes, elementId);
                    for (int j = 0; j < attribs.getRowCount(); j++) {
                        item.setAttribute(attribs.getString("ATTRIB_NAME", j), attribs.getString("ATTRIB_VALUE", j));
                    }


                    if (childElements != null) iterateElementTableRows(doc, item, childElements, attributes);
                }

            }
        } catch (Exception e) {
            e.printStackTrace();  //To change body of catch statement use File | Settings | File Templates.
        }
        return item;
    }

    private static synchronized Table getChildElements(Table elements, String elementId) {
        Table childElements = TableUtils.select(elements,
                new String[]{"ELEMENT_ID", "ELEMENT_NAME", "ELEMENT_TEXT", "ELEMENT_PARENT_ID"},
                new String[]{"ELEMENT_PARENT_ID=" + elementId});
        return childElements;
    }

    private static synchronized Table getElementAttributes(Table attributes, String elementId) {
        Table childElements = TableUtils.select(attributes,
                new String[]{"ELEMENT_ID", "ATTRIB_NAME", "ATTRIB_VALUE"},
                new String[]{"ELEMENT_ID=" + elementId});
        return childElements;
    }

    public static synchronized Document createDocumentInstance() throws ParserConfigurationException {
        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
        DocumentBuilder builder = factory.newDocumentBuilder();
        // Create document instance ...
        Document documnet = builder.newDocument();
        return documnet;
    }
/*
    public static void main(String[] args) {

        //String str = FileUtils.readStringFromFile("C:\\wdir\\jLab\\DocumentMill\\src\\java\\menu1.xml");
        String str = FileUtils.readStringFromFile("c:\\wdir\\jLab\\DocumentMill\\src\\java\\resources\\table.xml");

        DomIterator di = new DomIterator(BasicDom.parseXml(str, "", false));

        Table elements = di.getElementTable();
        System.out.println("elements = " + elements);

        Table attributes = di.getAttributeTable();
        System.out.println("attributes = " + attributes);

        Document doc = BasicDom.loadFromTable(elements, attributes);
        System.out.println("doc = " + doc.getDocumentElement());
    }
    */
}
//ElementAdapter//////////////////////////////////////////////////////////////////

import java.io.Serializable;

import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.NamedNodeMap;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;

public class ElementAdapter implements Serializable{
    private Element element;
    private int id = 0;
    private int parentId = -1;
    private int level = 0;
    private String identVal = "\t";


    public ElementAdapter(Element element) {
        this.element = element;
        setLevel();
    }

    public ElementAdapter(Element element, int id, int parentId) {
        this.element = element;
        this.id = id;
        this.parentId = parentId;
        setLevel();
    }

    public ElementAdapter(Element element, int id) {
        this.element = element;
        this.id = id;        
        setLevel();
    }
    
    public int getId() {
        return id;
    }

    public int getParentId() {
        return parentId;
    }

    public Element getElement() {
        return element;
    }

    public Document getOwnerDocument() {
        return element.getOwnerDocument();
    }
    
    public String getElementName() {
        return element.getNodeName();
    }

    public void setElement(Element element) {
        this.element = element;
    }

    public String getCDATA() {
        String txt = "";

        if (element.hasChildNodes()) {
            NodeList childNodes = element.getChildNodes();

            if (childNodes != null) {
                for (int j = 0; j < childNodes.getLength(); j++) {
                    if (childNodes.item(j) != null && childNodes.item(j).getNodeType() == Node.CDATA_SECTION_NODE) {
                        txt += childNodes.item(j).getNodeValue();
                    }
                }
            }
        }
        //else return null;
        return txt;
    }

    public String getText() {
        String txt = "";

        if (element.hasChildNodes()) {
            NodeList childNodes = element.getChildNodes();

            if (childNodes != null) {
                for (int j = 0; j < childNodes.getLength(); j++) {
                    if (childNodes.item(j) != null && childNodes.item(j).getNodeType() == Node.TEXT_NODE) {
                        txt +=  childNodes.item(j).getNodeValue();
                    }
                }
            }
        }
        //else return null;
        return txt;
    }

    public String getTextAndCDATA() {
        String txt = "";

        if (element.hasChildNodes()) {
            NodeList childNodes = element.getChildNodes();

            if (childNodes != null) {
                for (int j = 0; j < childNodes.getLength(); j++) {
                    if (childNodes.item(j) != null && childNodes.item(j).getNodeType() == Node.CDATA_SECTION_NODE ) {
                        txt += childNodes.item(j).getNodeValue();
                    }
                    
                    if (childNodes.item(j) != null && childNodes.item(j).getNodeType() == Node.TEXT_NODE ) {
                        txt += childNodes.item(j).getNodeValue();                     
                    }
                }
            }
        }
        //else return null;
        return txt;
    }

    public String getAttrVal(String name) {
        return element.getAttribute(name);
    }

    public int getLevel() {

        return level;
    }

    public void setLevel() {

        Node temp = element;
        if (temp == null) return;
        while ((temp = temp.getParentNode()) != null) {
            if (temp.getNodeType() == Node.ELEMENT_NODE) level++;
        }

    }

    public String getIdentVal() {
        return identVal;
    }

    public void setIdentVal(String identVal) {
        this.identVal = identVal;
    }
//
//    public String getPath() {
//        String retVal = "/" + element.getNodeName();
//        Node temp = element;
//        if (temp == null) return "";
//        while ((temp = temp.getParentNode()) != null) {
//            if (temp.getNodeType() == Node.ELEMENT_NODE)
//                retVal = "/" + temp.getNodeName() + retVal;
//        }
//        return retVal;
//    }

    public String getXPath() {
        String retVal = "/" + element.getNodeName() + "[" + getElementSiblingIndex(element) + "]";
        Node temp = element;
        if (temp == null) return "";
        while ((temp = temp.getParentNode()) != null) {
            if (temp.getNodeType() == Node.ELEMENT_NODE)
                retVal = "/" + temp.getNodeName() + "[" + getElementSiblingIndex((Element) temp) + "]" + retVal;
        }
        return retVal;
    }

    public int getElementSiblingIndex(Element e) {
        Node sibling = e.getPreviousSibling();
        int elementIdx = 1;

        while (sibling != null) {
            if (sibling.getNodeType() == Node.ELEMENT_NODE && sibling.getNodeName().equals(e.getNodeName())) {
                elementIdx++;
            }
            sibling = sibling.getPreviousSibling();
        }
        return elementIdx;
    }

    public String attributesToString() {
        String retVal = "";
        NamedNodeMap attrMap = element.getAttributes();
        for (int i = 0; i < attrMap.getLength(); i++) {
            Node attr = attrMap.item(i);
            String attrName = attr.getNodeName();
            String attrValue = getAttrVal(attrName);
            retVal = retVal + attrName + "=\"" + attrValue + "\" ";
        }
        return retVal;
    }

    public String getIdent() {
        int i = getLevel();
        StringBuffer sb = new StringBuffer("");
        while (i-- > 0) sb.append(identVal);
        return sb.toString();
    }

    public String toString() {
        return "ElementAdapter{" +
                "element=" + element +
                ", id=" + id +
                ", parentId=" + parentId +
                "}";
    }
    

//    public static String encode(String str){
//    	return str.replaceAll("<","&lt;").replaceAll(">","&gt;").replaceAll("\"","&quot;");
//    }
    
//    public static String decode(String str){
//    	return str.replaceAll("&lt;","<").replaceAll("&gt;",">").replaceAll("&quot;","\"");
//    }
}
///////////////////////////////////////////////////////////////////

import java.util.Hashtable;

import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.NamedNodeMap;
import org.w3c.dom.Node;

import com.jcocktail.utils.file.TextFile;

public class NodeToHTMLTable extends NodeIterator {

    StringBuffer sb = new StringBuffer();
    int eId = 0;
    int eIdx = 1;
    //String currentElementName ="";
    String lastElementName = "";

    Hashtable elementMap = new Hashtable();
    
    boolean showFileData=false;
    

    public boolean isShowFileData() {
		return showFileData;
	}

	public void setShowFileData(boolean showFileData) {
		this.showFileData = showFileData;
	}

	public NodeToHTMLTable(Node n) throws Exception {
        super();
        followNode(n);
    }

    public Element getElement(Object key) {
        return (Element) elementMap.get(key);
    }

    /* (non-Javadoc)
    * @see com.docmill.utils.xml.dom.NodeIterator#processNode(org.w3c.dom.Node)
    */
    protected void processNode(Node node) {
        if (node.getNodeType() != Node.ELEMENT_NODE) return;
        eId++;
        ElementAdapter ea = new ElementAdapter((Element) node);

        if (!lastElementName.equals(ea.getElementName())) {
            eIdx = 1;
        }
        String elementKey = String.valueOf(node.hashCode());
        elementMap.put(elementKey, (Element) node);

        //System.out.println(ea.getXPath());

        //System.out.println((eId++) + ea.getPath().replaceAll("/", "-") + "-" + eIdx++);
//        DomElemzentEvaluator eval = new DomElementEvaluator((Element) node);

//        String retVal = null;
//        try {
//            retVal = eval.evalExp("${IDENT}<${NAME} ${ATTRIB_LIST}>${TEXT_CDATA}");
//        } catch (Exception e) {
//            e.printStackTrace();  //To change body of catch statement use File | Settings | File Templates.
//        }
//        System.out.println(retVal);

//        sb.append("\n").append(ea.getIdent()).append("<TABLE border=\"1\" bordercolor=\"#9BB5D0\" width=\"100%\" cellspacing=\"0\" cellpadding=\"2\"><TR><TD width=\"5\" bgcolor=\"#E2AAAA\" align=\"center\" valign=\"top\" rowspan=\"2\">-</TD><TD bgcolor=\"#E2DEDC\" valign=\"top\"><I><B>").
//                append(ea.getElementName()).append("</B></I></TD><TD>").append(getAttributeHTMLTableV2(ea)).append(
//                "</TD></TR><TR><TD colspan=\"2\">");
        sb.
                append("<font color=\"003399\" face=\"Arial, Helvetica\" size=2>\n").
                append("\t\t<a id=\"xCell_").append(eId).append("\" style=\"CURSOR: auto;\" onclick=\"ShowHide('Cell_").append(eId).
                append("');\" href=\"#xCell_").append(eId).append("\" >\n").
                append("\t\t\t<font face=Arial,helvetica color=#aa0000 size=1><b>&gt;&gt;</b></font>\n").
                append("\t\t</a>\n").
                append("\t\t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n").
                append("\t\t<a href=\"DirectoryDetail.jsp?perform=Update&RECORD_ID=").append(eId).append(
                "\"><font face=\"Arial,helvetica\" color=\"#aa0000\" size=\"1\">edit</font></a>&nbsp;\n").
                append("\t\t<a href=\"DirectoryDetail.jsp?perform=Print&elementKey=").append(elementKey).append(
                "\"><font face=\"Arial,helvetica\" color=\"#aa0000\" size=\"1\">print</font></a>&nbsp;\n").
                append("\t\t<a href=\"javascript:openThis('PrintNode.jsp?elementKey=").append(elementKey).append(
                "','card',376,264,(screen.availWidth/2 - 376/2),(screen.availHeight/2 - 240/2))\"><font face=\"Arial,helvetica\" color=\"#aa0000\" size=\"1\">print</font></a>&nbsp;\n").
                append("\t\t<fieldset>\n").
                append("\t\t<legend>\n").
                append("\t\t\t<a href=\"javascript:openThis('PrintNode.jsp?elementKey=").append(elementKey).append(
                "','card',376,264,(screen.availWidth/2 - 376/2),(screen.availHeight/2 - 240/2),'yes','yes','no')\">\n").
                append("\t\t\t\t<font face=\"Arial,helvetica\" color=\"#aa0000\" size=\"3\">\n").
                append("\t\t\t\t\t<b><i>").append(ea.getElementName()).append("</i></b>\n").append("\t\t\t\t</font>\n").
                append("\t\t\t</a>&nbsp;\n").append("\t\t</legend>\n").
                append("\t\t<div id=\"Cell_").append(eId).append("\" style=\"padding: 5px; DISPLAY: ").append(getLevel() > 1 ? "none" : "block").append(";\">\n").
                append("\t\t<TABLE border=\"0\" bordercolor=\"#9BB5D0\" width=\"100%\" cellspacing=\"0\" cellpadding=\"2\">\n").
                append("\t\t\t<TR>\n").
                append("\t\t\t\t<TD width=\"5\" bgcolor=\"white\" align=\"center\" valign=\"top\" rowspan=\"2\">-</TD>\n").
                append("\t\t\t\t<TD bgcolor=\"#E2DEDC\" valign=\"top\">\n").
                //append("\t\t\t\t\t<I><B>").append(ea.getElementName()).append("</B></I>\n").
                        append("\t\t\t\t</TD>\n").append("\t\t\t<TD>\n").
                append("\t\t\t\t").append(getAttributeHTMLTableV2(ea)).append("\t\t\n").
                append("\t\t\t</TD>\n").append("\t\t</TR>\n").
                append("\t\t<TR>\n").
                append("\t\t<TD colspan=\"2\">");
        lastElementName = ea.getElementName();
    }

    protected void postProcessNode(Node node) {
        if (node.getNodeType() != Node.ELEMENT_NODE) return;
        ElementAdapter ea = new ElementAdapter((Element) node);
        if (showFileData && ea.getTextAndCDATA() != null && !"".equals(ea.getTextAndCDATA().trim())) {
            sb.append("<PRE>").append(ea.getTextAndCDATA()).append("</PRE>");
        }

        ///////////////////////////////////////////////
        sb.append("\t\t</TD>\n\t</TR></TABLE>\n");
        sb.append("\t\t</div>\n").append("\t</fieldset>\n").append("</font>&nbsp;");
        ///////////////////////////////////////////////
//        DomElementEvaluator eval = new DomElementEvaluator((Element)node);
//        String retVal = null;
//        try {
//            retVal = eval.evalExp("${IDENT}</${NAME}>");
//        } catch (Exception e) {
//            e.printStackTrace();  //To change body of catch statement use File | Settings | File Templates.
//        }
//        System.out.println(retVal);
        ///////////////////////////////////////////////
    }

    private String getAttributeHTMLTableV1(ElementAdapter ea) {
        StringBuffer sb = new StringBuffer("<TABLE border=\"1\" width=\"100%\" bordercolor=\\\"white\\\" cellspacing=\"1\" cellpadding=\"2\">");
        StringBuffer names = new StringBuffer("<TR bgcolor=\"#BEC5D3\">");
        StringBuffer vals = new StringBuffer("<TR>");

        NamedNodeMap attrMap = ea.getElement().getAttributes();

        for (int i = 0; i < attrMap.getLength(); i++) {
            Node attr = attrMap.item(i);
            String attrName = attr.getNodeName();
            String attrValue = ea.getAttrVal(attrName);
            names.append("<TD>").append(attrName).append("</TD>");
            vals.append("<TD>").append(attrValue).append("</TD>");
        }
        names.append("</TR>");
        vals.append("</TR>");
        sb.append(names).append(vals);
        sb.append("</TABLE>");

        return sb.toString();
    }

    private String getAttributeHTMLTableV2(ElementAdapter ea) {
        StringBuffer sb = new StringBuffer("<TABLE border=\"0\" " +
                //"width=\"100%\" " +
                "cellspacing=\"0\" " +
                "cellpadding=\"2\">");

        NamedNodeMap attrMap = ea.getElement().getAttributes();

        for (int i = 0; i < attrMap.getLength(); i++) {

            Node attr = attrMap.item(i);
            String attrName = attr.getNodeName();
            String attrValue = ea.getAttrVal(attrName);
            sb.append("<TR bgcolor=\"#BEC5D3\"><TD width=\"5\" align=\"center\" valign=\"top\">-</TD><TD valign=\"top\"><B>").append(attrName).append("</B></TD><TD bgcolor=\"#E0E0D1\">").append(attrValue).append("</TD></TR>");

        }

        sb.append("</TABLE>");

        return sb.toString();
    }

    private String getAttributeHTMLTableV3(ElementAdapter ea) {
        StringBuffer sb = new StringBuffer("<TABLE border=\"0\" width=\"100%\" cellspacing=\"0\" cellpadding=\"2\">");

        sb.append("<TR bgcolor=\"#BEC5D3\"><TD width=\"5\" align=\"center\" valign=\"top\">-</TD><TD bgcolor=\"#E0E0D1\">").append(ea.attributesToString()).append("</TD></TR>");

        sb.append("</TABLE>");

        return sb.toString();
    }

//    public static String getJS(){
//    	//Java Script
//    	StringBuffer sb = new StringBuffer();
//    	sb.append("<script language=JavaScript>\n");
//    	sb.append("<!--\n");
//    	sb.append("\n");
//    	sb.append("function toggle(obj){\n");
//    	sb.append(" if(obj.style.display=='none')\n");
//    	sb.append("   obj.style.display='block';\n");
//    	sb.append(" else\n");
//    	sb.append("   obj.style.display='none';\n");
//    	sb.append("}\n");
//    	sb.append("\n");
//    	sb.append("function ShowHide( ref )\n");
//    	sb.append("{\n");
//    	sb.append("  var color;\n");
//    	sb.append("  //if( ref == 'Structure' )\n");
//    	sb.append("    color = 'aa0000';\n");
//    	sb.append("  //else\n");
//    	sb.append("    //color = '007733';\n");
//    	sb.append("\n");
//    	sb.append("  if (eval(ref).style.display =='none')\n");
//    	sb.append("  {\n");
//    	sb.append("     eval('x' + ref).innerHTML = '<font face=\"Arial,helvetica\" color=' + color + ' size=1><b>X</b></font>';\n");
//    	sb.append("     eval(ref).style.display ='';\n");
//    	sb.append("  }\n");
//    	sb.append("  else\n");
//    	sb.append("  {\n");
//    	sb.append("     eval('x' + ref).innerHTML = '<font face=\"Arial,helvetica\" color=' + color + ' size=1><b>&gt;&gt;</b></font>';\n");
//    	sb.append("     eval(ref).style.display ='none';\n");
//    	sb.append("  }\n");
//    	sb.append("}\n");
//    	sb.append("//-->\n");
//    	sb.append("</script>\n");
//        return sb.toString();
//    }

    public String toString() {

        sb.append("<script language=JavaScript>\n");
        sb.append("<!--\n");
        sb.append("\n");
        sb.append("function toggle(obj){\n");
        sb.append(" if(obj.style.display=='none')\n");
        sb.append("   obj.style.display='block';\n");
        sb.append(" else\n");
        sb.append("   obj.style.display='none';\n");
        sb.append("}\n");
        sb.append("\n");
        sb.append("function ShowHide( ref )\n");
        sb.append("{\n");
        sb.append("  var color;\n");
        sb.append("  //if( ref == 'Structure' )\n");
        sb.append("    color = 'aa0000';\n");
        sb.append("  //else\n");
        sb.append("    //color = '007733';\n");
        sb.append("\n");
        sb.append("  if (eval(ref).style.display =='none')\n");
        sb.append("  {\n");
        sb.append("     eval('x' + ref).innerHTML = '<font face=\"Arial,helvetica\" color=' + color + ' size=1><b>X</b></font>';\n");
        sb.append("     eval(ref).style.display ='';\n");
        sb.append("  }\n");
        sb.append("  else\n");
        sb.append("  {\n");
        sb.append("     eval('x' + ref).innerHTML = '<font face=\"Arial,helvetica\" color=' + color + ' size=1><b>&gt;&gt;</b></font>';\n");
        sb.append("     eval(ref).style.display ='none';\n");
        sb.append("  }\n");
        sb.append("}\n");
        sb.append("//-->\n");
        sb.append("</script>\n");
        return sb.toString();
    }

    public static void main(String[] args) throws Exception {
        //TextFile xmlFile = new TextFile("c:\\wdir\\DPMX\\web\\WEB-INF\\HTMLTable_DIRECTORY.xml", true);
        TextFile xmlFile = new TextFile("c:\\dev\\CDS\\doc\\design\\deliveryConfig_sample.xml", true);
        Document d = BasicDom.parseXml(xmlFile.getContent(), "", false);

        NodeToHTMLTable html = new NodeToHTMLTable(d);
        TextFile htmlFile = new TextFile("C:\\dev\\CDS\\doc\\design\\deliveryConfig_GUI_sample.html", true);
        //TextFile htmlFile = new TextFile("c:\\wdir\\DPMX\\web\\WEB-INF\\HTMLTable_DIRECTORY.XMLGUI.html", true);
        htmlFile.println("<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.0 Transitional//EN\">", false);
        htmlFile.println("<HTML>");
        htmlFile.println("<HEAD>");
        htmlFile.println("<TITLE> XML Web GUI </TITLE>");
        htmlFile.println("</HEAD>");
        htmlFile.println("<BODY>");
        htmlFile.println("<H3>Delivery Process Config Page</H3>");
        htmlFile.println("<HR width=\"100%\">");
        htmlFile.println(html.toString());
        htmlFile.println("</BODY>");
        htmlFile.println("</HTML>");

        //TextFile textFile = new TextFile("C:\\dev\\CDS\\doc\\design\\deliveryConfig_GUI_sample.html",true);
        //System.out.println(textFile.getContent());
    }
}

////////////////////////////////////////////////////////////////////
	/**
	 * REST API: /download
	 * 
	 * @param fileDetailsId
	 * @param response
	 * @throws IOException
	 */
	@RequestMapping(value = "/v1/downloadFile", method = RequestMethod.GET, produces = { "application/octet-stream" })
	public void downloadFile(@RequestParam(value = "fileDetailsId", required = true) Long fileDetailsId,
			@Context HttpServletResponse response, HttpServletRequest request) throws IOException {

		recordLogging(request, true, JsonUtil.toJson(request.getParameterMap()));
		FileDetails fileDetails1 = fileDetailsRepository.findOne(fileDetailsId);

		response.setContentLength(fileDetails1.getFileContent().length);
		response.setHeader("Content-Disposition", "attachment; filename=" + fileDetails1.getFileName());

		ServletOutputStream outStream = response.getOutputStream();
		InputStream in = new ByteArrayInputStream(fileDetails1.getFileContent());

		try {
			byte[] bbuf = new byte[1024];
			int length = 0;
			while ((in != null) && ((length = in.read(bbuf)) != -1)) {
				outStream.write(bbuf, 0, length);
			}

		} catch (Exception e) {
			recordError(request, false, e);
		} finally {
			in.close();
			outStream.flush();
		}
		recordLogging(request, false, "");
	}

	/**
	 * REST API: /upload
	 * 
	 * @param requestId
	 * @param fileTypes
	 * @param files
	 * @return
	 * @throws Exception
	 */
	@RequestMapping(value = "/v1/uploadFile", method = RequestMethod.POST)
	public @ResponseBody Boolean uploadFile(@RequestParam(value = "requestId", required = true) Long requestId,
			@RequestParam(value = "fileType", required = true) String[] fileTypes,
			@RequestParam(value = "file", required = true) MultipartFile[] files, HttpServletRequest request) throws Exception {

		if (fileTypes != null && files != null && fileTypes.length != files.length)
			throw new Exception("Number of fileType parameters and file parameters has to be the same!");

		WorkflowRequest wfr = workflowRequestRepository.findOne(requestId);
		List<FileDetails> fileDetailsList = new ArrayList<FileDetails>();
		for (int i = 0; i < files.length; i++) {
			
			try //Validate attachment files
			{
				validateFile(files[i]);

			} catch (ExceptionResponse er)
			{
				recordError(request, false, er);
				throw er;
			}
			
			FileDetails fileDetails = new FileDetails();
			fileDetails.setFileName(files[i].getOriginalFilename());
			fileDetails.setFileType(fileTypes[i]);
			fileDetails.setRequestDetails(wfr.getRequestDetails());
			fileDetails.setFileContent(files[i].getBytes());
			fileDetailsList.add(fileDetails);

		}

		fileDetailsRepository.save(fileDetailsList);

		return true;
	}



///////////////////////////////////////////////////////////////////////////////
@RequestMapping(value = "/downloadFile", method = RequestMethod.GET, produces =
	{ "application/octet-stream" })
	public void downloadFile(@RequestParam(value = "fileDetailsId", required = true) Long fileDetailsId,
			@Context HttpServletResponse response, HttpServletRequest request)
			throws IOException, RestClientException, CarpException
	{
		recordLogging(request, true, JsonUtil.toJson(request.getParameterMap()));
		
		String url = restConfig.getAccessUrl() + restConfig.getCarpservicesUri() + "/v1/downloadFile?fileDetailsId="
				+ fileDetailsId;
		LOGGER.info(url);

		HttpHeaders headers = new HttpHeaders();
		headers.setAccept(Arrays.asList(MediaType.APPLICATION_OCTET_STREAM));

		ResponseEntity<byte[]> responseEntity = getRestTemplate(request).exchange(url, HttpMethod.GET,
				new HttpEntity(headers), byte[].class, "1");

		HttpHeaders respHeaders = responseEntity.getHeaders();

		response.setContentLength(responseEntity.getBody().length);

		response.setHeader("Content-Disposition", respHeaders.get("Content-Disposition").get(0));

		ServletOutputStream outStream = response.getOutputStream();

		InputStream in = new ByteArrayInputStream(responseEntity.getBody());

		try
		{
			byte[] bbuf = new byte[1024];
			int length = 0;
			while ((in != null) && ((length = in.read(bbuf)) != -1))
			{
				outStream.write(bbuf, 0, length);
			}

			recordLogging(request, false, "");
		} catch (Exception e)
		{
			recordError(request, false, e);
			
		} finally
		{
			in.close();
			outStream.flush();
		}
	}

	/**
	 * REST API: /upload
	 * 
	 * @param requestId
	 * @param fileTypes
	 * @param files
	 * @return
	 * @throws Exception
	 */
	@RequestMapping(value = "/uploadFile", method = RequestMethod.POST)
	public @ResponseBody Boolean uploadFile(@RequestParam(value = "requestId", required = true) Long requestId,
			@RequestParam(value = "fileType", required = true) String[] fileTypes,
			@RequestParam(value = "file", required = true) MultipartFile[] files, HttpServletRequest request)
			throws Exception
	{
		recordLogging(request, true, JsonUtil.toJson(request.getParameterMap()));
		
		String url = restConfig.getAccessUrl() + restConfig.getCarpservicesUri() + "/v1/uploadFile";
		LOGGER.info(url);

		MultiValueMap<String, Object> map = new LinkedMultiValueMap<String, Object>();
		map.add("requestId", requestId);

		for ( int i = 0 ; i < fileTypes.length ; i++ )
		{
			map.add("fileType", fileTypes[i]);
		}

		for ( int i = 0 ; i < files.length ; i++ )
		{
			map.add("file", new FileMessageResource(files[i].getBytes(), files[i].getOriginalFilename()));
		}

		HttpEntity<LinkedMultiValueMap<String, Object>> requestEntity = new HttpEntity<LinkedMultiValueMap<String, Object>>(
				(LinkedMultiValueMap<String, Object>) map);
		Boolean result = getRestTemplate(request).postForObject(url, requestEntity, Boolean.class);
		result = (result == null) ? new Boolean(false) : result;
		recordLogging(request, false, JsonUtil.toJson(result));
		return result;
		

	}
	


///////////////////////////////////////////////////////////////
import org.springframework.core.io.ByteArrayResource;

/**
 * @author drapig3 - Nov. 2016
 *
 */
public class FileMessageResource extends ByteArrayResource
{

	/**
	 * The filename to be associated with the file data.
	 */
	private final String filename;

	public FileMessageResource(final byte[] byteArray, final String filename)
	{
		super(byteArray);
		this.filename = filename;
	}

	@Override
	public String getFilename()
	{

		return filename;
	}
}

////////////////////////////////////////////////////////////////////
		ServletOutputStream outStream = null;

		InputStream in = null;

		try
		{
			HttpHeaders headers = new HttpHeaders();
			headers.setAccept(Arrays.asList(MediaType.APPLICATION_OCTET_STREAM));

			ResponseEntity<byte[]> responseEntity = getRestTemplate(request).exchange(url, HttpMethod.POST,
					new HttpEntity(reportApprovedReq, headers), byte[].class, "1");

			HttpHeaders respHeaders = responseEntity.getHeaders();

			response.setContentLength(responseEntity.getBody().length);
			response.setHeader("@RequestMapping(value = "/submitDataAccessWorkflowRequest", method = RequestMethod.POST)
	public @ResponseBody ResponseEntity submitDataAccessWorkflowRequest(
			@RequestParam(value = "workflowRequest", required = true) String workflowRequestStr,
			@RequestParam(value = "piaFile", required = false) MultipartFile piaFile,
			@RequestParam(value = "otherFile4", required = false) MultipartFile otherFile4,
			@RequestParam(value = "otherFile1", required = false) MultipartFile otherFile1,
			@RequestParam(value = "otherFile2", required = false) MultipartFile otherFile2,
			@RequestParam(value = "otherFile3", required = false) MultipartFile otherFile3, HttpServletRequest request)
			throws IOException, CarpException
	{
		recordLogging(request, true, JsonUtil.toJson(request.getParameterMap()));
		
		String url = restConfig.getAccessUrl() + restConfig.getCarpservicesUri()
				+ "/v1/submitDataAccessWorkflowRequest";
		LOGGER.info(url);

		MultiValueMap<String, Object> map = new LinkedMultiValueMap<String, Object>();

		map.add("workflowRequest", workflowRequestStr);

		if ( piaFile != null )
		{
			map.add("piaFile", new FileMessageResource(piaFile.getBytes(), piaFile.getOriginalFilename()));
		}
		if ( otherFile4 != null )
		{
			map.add("otherFile4", new FileMessageResource(otherFile4.getBytes(), otherFile4.getOriginalFilename()));
		}
		if ( otherFile1 != null )
		{
			map.add("otherFile1", new FileMessageResource(otherFile1.getBytes(), otherFile1.getOriginalFilename()));
		}
		if ( otherFile2 != null )
		{
			map.add("otherFile2", new FileMessageResource(otherFile2.getBytes(), otherFile2.getOriginalFilename()));
		}
		if ( otherFile3 != null )
		{
			map.add("otherFile3", new FileMessageResource(otherFile3.getBytes(), otherFile3.getOriginalFilename()));
		}

		HttpEntity<LinkedMultiValueMap<String, Object>> requestEntity = new HttpEntity<LinkedMultiValueMap<String, Object>>(
				(LinkedMultiValueMap<String, Object>) map);

		//Boolean result =  getRestTemplate(request).postForObject(url, requestEntity, Boolean.class);
		//return result==null?new Boolean(false):result;
		ResponseEntity resp =  getRestTemplate(request).exchange(url, HttpMethod.POST, requestEntity,
				new ParameterizedTypeReference<ResponseDetails<Boolean>>()
				{
				});
		
		recordLogging(request,false,JsonUtil.toJson(resp==null?null:resp.getBody()));
		return resp;
	}Content-Disposition", respHeaders.get("Content-Disposition").get(0));

			//			response.setContentType("txt/csv");
			//			response.addHeader(name, value);

			outStream = response.getOutputStream();

			in = new ByteArrayInputStream(responseEntity.getBody());

			byte[] bbuf = new byte[1024];
			int length = 0;
			while ((in != null) && ((length = in.read(bbuf)) != -1))
			{
				outStream.write(bbuf, 0, length);
			}

		} catch (Exception e)
		{
			//	        e.printStackTrace();
		} finally
		{
			try
			{
				if ( outStream != null )
					outStream.flush();
				if ( in != null )
					in.close();
			} catch (IOException e)
			{
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		}
