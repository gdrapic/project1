//NodeIterator//////////////////////////////////////////////////////
package com.jcocktail.utils.xml.dom;

import org.w3c.dom.Node;
import org.w3c.dom.NodeList;

// Depth first search of DOM Tree

public abstract class NodeIterator {
    int level = 0;

    // note use of recursion
    public void followNode(Node node) throws Exception {

        processNode(node);
        if (node.hasChildNodes()) {
            NodeList children = node.getChildNodes();
            for (int i = 0; i < children.getLength(); i++) {
                level++;
                followNode(children.item(i));
                level--;
            }
        }
        postProcessNode(node);

    }

    public int getLevel() {
        return level;
    }

    // Override this method to do something as each node is visited
    protected abstract void processNode(Node node) throws Exception;

    // I could make processNode() a separate method in
    // a NodeProcessor interface, and make followNode static
    // but I wanted to keep this example simple.
    protected abstract void postProcessNode(Node node) throws Exception;

}

//DOMPrinter/////////////////////////////////////////////////////////////////

import java.io.IOException;
import java.io.Writer;

import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.NamedNodeMap;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;

public class DOMPrinter extends NodeIterator{
	
	private Writer out;
	private String encoding = "UTF-8";
	private String lineSeparator = System.getProperty("line.separator");
	private boolean printDeclaration = true;
	private String identStr = "\t";
	
	public DOMPrinter() {
		super();
	}
	
	public DOMPrinter(Writer out) {
		super();
		this.out = out;
	}

	public String getEncoding() {
		return encoding;
	}

	public void setEncoding(String encoding) {
		this.encoding = encoding;
	}

	public boolean isPrintDeclaration() {
		return printDeclaration;
	}

	public void setPrintDeclaration(boolean printDeclaration) {
		this.printDeclaration = printDeclaration;
	}
	
	public String getIdentStr() {
		return identStr;
	}

	public void setIdentStr(String identStr) {
		this.identStr = identStr;
	}

	public String getLineSeparator() {
		return lineSeparator;
	}

	public void setLineSeparator(String lineSeparator) {
		this.lineSeparator = lineSeparator;
	}

	public void write(Writer out, Node node) throws Exception{
		if(node.getNodeType() == Node.DOCUMENT_NODE){			
			node = ((Document)node).getDocumentElement();			
		}
			
		this.out = out;
		if(printDeclaration) write("<?xml version=\"1.0\" encoding=\"" + encoding + "\"?>");
		followNode(node);
	}
	
	public String getIdent(String identVal) {
        int i = getLevel();
        StringBuffer sb = new StringBuffer("");
        while (i-- > 0) sb.append(identVal);
        return sb.toString();
    }
	
	private void write(String str) throws IOException{
		out.write(new String(str.getBytes(),encoding));		
	}
	
	public String attributesToString(Element element) {
        String retVal = "";
        NamedNodeMap attrMap = element.getAttributes();
        for (int i = 0; i < attrMap.getLength(); i++) {
            Node attr = attrMap.item(i);
            String attrName = attr.getNodeName();
            String attrValue = element.getAttribute(attrName);
            retVal = retVal + " " + attrName + "=\"" + attrValue + "\"";
        }
        return retVal;
    }
	
	public String getCDATA(Element element) {
        String txt = "";

        if (element.hasChildNodes()) {
            NodeList childNodes = element.getChildNodes();

            if (childNodes != null) {
                for (int j = 0; j < childNodes.getLength(); j++) {
                    if (childNodes.item(j) != null && childNodes.item(j).getNodeType() == Node.CDATA_SECTION_NODE) {
                        txt += childNodes.item(j).getNodeValue();
                    }
                }
            }
        }
        //else return null;
        return txt;
    }
	
	public String getTextContent(Element element) {
        String txt = "";

        if (element.hasChildNodes()) {
            NodeList childNodes = element.getChildNodes();

            if (childNodes != null) {
                for (int j = 0; j < childNodes.getLength(); j++) {
                    if (childNodes.item(j) != null && childNodes.item(j).getNodeType() == Node.TEXT_NODE) {
                        txt +=  childNodes.item(j).getNodeValue();
                    }
                }
            }
        }
        /* Replace XML special characters...
	    1.  & - &amp;
			2. < - &lt;
			3. > - &gt;
			4. " - &quot;
			5. ' - &#39; 
			
         */
        return txt.
        	replaceAll("&", "&amp;").
			replaceAll("<", "&lt;").
			replaceAll(">", "&gt;").							
			replaceAll("\"", "&quot;").
			replaceAll("'", "&#39;");
			
    }
	
	protected void processNode(Node node) throws Exception {	
		
		if(node.getNodeType() == Node.COMMENT_NODE){
			write(getIdent(identStr));
			write("<!-- ");
			write(node.getNodeValue());
			write(" -->".concat(lineSeparator));
			return;
		}
		if(node.getNodeType() != Node.ELEMENT_NODE) return;
				
		//Do not write a new line separator if 'out' is empty
		if(out.toString().trim().length()>0)write(lineSeparator);
		
		write(getIdent(identStr));
		write("<");
		write(node.getNodeName());
		
		String attributes = attributesToString((Element)node);
		if(!"".equals(attributes.trim())) write(" ");
		write(attributes);
		if (node.hasChildNodes()){
			write(">");	
			
			String text = getTextContent((Element)node);
			
			if (!"".equals(text.trim())){				
				write(text);				
			}			
			
			String cdata = getCDATA((Element)node).trim();
			if (!"".equals(cdata)){
//				write(getIdent(identStr));
				write("<![CDATA[");
				write(cdata);
				write("]]>");
			}						
		}
		else{
			write("/>");
		}
		out.flush();
		
	}

	protected void postProcessNode(Node node) throws Exception {
		if(node.getNodeType() != Node.ELEMENT_NODE) return;
		ElementAdapter ea = new ElementAdapter((Element)node);
		if (ea.getElement().hasChildNodes()){
			if ("".equals(ea.getTextAndCDATA().trim())){
				write(lineSeparator.concat(getIdent(identStr)));
			}
			write("</");
			write(ea.getElementName());
			write(">");
		}	
		out.flush();		
	}
	
	public static void main(String[] args) throws Exception {
		java.io.StringWriter w = new java.io.StringWriter();
		DOMPrinter dw = new DOMPrinter(w);
		dw.setPrintDeclaration(false);
		Document d = BasicDom.parseXml("<root>\n" +
				"\t<firstChild attrib1=\"ATTRIB1\">TEXT1--</firstChild>" +
				"<secondChild >TTTasdf\n<![CDATA[**sdfsdf**]]>sdasdfsdaf</secondChild>" +
				"</root>", null, false);
		dw.write(w,d);
		System.out.println(w);
	}
}
//BasicDom//////////////////////////////////////////////////////////////////

import java.io.File;
import java.io.IOException;
import java.io.StringReader;
import java.io.StringWriter;
import java.io.Writer;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.transform.Result;
import javax.xml.transform.Source;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerConfigurationException;
import javax.xml.transform.TransformerException;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;

import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.xml.sax.InputSource;
import org.xml.sax.SAXException;

import com.jcocktail.utils.data.Table;
import com.jcocktail.utils.data.TableUtils;

public class BasicDom {

    // Parses an XML file and returns a DOM document.
    // If validating is true, the contents is validated against the DTD
    // specified in the file.
    public static synchronized Document parseXmlFile(String filename, boolean validating) throws ParserConfigurationException, IOException, SAXException {
        //try {
        // Create a builder factory
        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
        factory.setValidating(validating);

        // Create the builder and parse the file
        Document doc = factory.newDocumentBuilder().parse(new File(filename));
        return doc;
        //} catch (SAXException e) {
        // A parsing error occurred; the xml input is not valid
        //} catch (ParserConfigurationException e) {
        //} catch (IOException e) {
        //}
        //return null;
    }

    /**
     * @param s
     * @param systemId
     * @param validating
     * @return
     */
    public static synchronized Document parseXml(String s, String systemId, boolean validating) {
        InputSource is = new InputSource();
        is.setCharacterStream(new StringReader(s));

        if (systemId != null || "".equals(systemId)) is.setSystemId(systemId);

        try {

            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
            DocumentBuilder builder = factory.newDocumentBuilder();
            factory.setValidating(validating);

            Document doc = builder.parse(is);
            return doc;
        } catch (SAXException sxe) {
            // Error generated during parsing)
            Exception x = sxe;
            if (sxe.getException() != null)
                x = sxe.getException();
            x.printStackTrace();

        } catch (ParserConfigurationException pce) {
            // Parser with specified options can't be built
            pce.printStackTrace();

        } catch (IOException ioe) {
            // I/O error
            ioe.printStackTrace();
        }
        return null;
    }

    public static String writeXml(Document doc) {
    	String xml = null;
    	StringWriter out = new StringWriter();
    	writeXml(doc,new StreamResult(new StringWriter()));
    	xml = out.toString();
    	return xml;
    }
    
//  This method writes a DOM document to a file
    public static void writeXml(Document doc, Writer writer) {
    	writeXml(doc,new StreamResult(writer));
    }
    
    //  This method writes a DOM document to a file
    public static void writeXml(Document doc, File file) {
    	writeXml(doc,new StreamResult(file));
    }
    
    public static void writeXml(Document doc, Result result) {
        try {
            // Prepare the DOM document for writing
            Source source = new DOMSource(doc);
            // Write the DOM document to the file
            Transformer xformer = TransformerFactory.newInstance().newTransformer();
            xformer.transform(source, result);
        } catch (TransformerConfigurationException e) {
        } catch (TransformerException e) {
        }
    }

    //TODO: This method is in development. Don't use it!!!
    public static synchronized Document loadFromTable(Table elements, Table attributes) {
        try {

            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
            DocumentBuilder builder = factory.newDocumentBuilder();

            Document doc = builder.newDocument();
            Element item = iterateElementTableRows(doc, null, elements, attributes);

            System.out.println("element = " + item);
            doc.appendChild(item);
//            try {
//                Element element = null;
//                for (int i = 0; i < elements.getRowCount(); i++) {
//                    String elementId = elements.getString("ELEMENT_ID", i);
//                    String elementName = elements.getString("ELEMENT_NAME", i);
//                    String elementText = elements.getString("ELEMENT_TEXT", i);
//                    String elementParentId = elements.getString("ELEMENT_PARENT_ID", i);
//
//                    element = doc.createElement(elementName);
//
//                    Table childElements = getChildElements(elements, elementId);
//                    if (childElements != null) {
//                        for (int k = 0; k < childElements.getRowCount(); k++) {
//                            Node n = element.appendChild(doc.createElement(childElements.getString("ELEMENT_NAME", k)));
//
//                        }
//                    }
//
//                    System.out.println("childElements = " + childElements);
////                    while ((childElements = getChildElements(childElements, elementParentId)) != null){
////                        System.out.println("childElements = " + childElements);
////                    }
//
//                    element.appendChild(doc.createTextNode(elementText));
//
//                    Table attribs = TableUtils.select(attributeTable,
//                            new String[]{"ELEMENT_ID", "ATTRIB_NAME", "ATTRIB_VALUE"},
//                            new String[]{"ELEMENT_ID=" + elementId});
//
//                    if (attribs != null) {
//                        for (int j = 0; j < attribs.getRowCount(); j++) {
//                            String name = attribs.getString("ATTRIB_NAME", j);
//                            String value = attribs.getString("ATTRIB_VALUE", j);
//                            element.setAttribute(name, value);
//                        }
//                    }
//                }
//                Element menu = doc.createElement("menu");
//                menu.appendChild(element);
//                doc.appendChild(menu);
//
//            } catch (Exception e) {
//                e.printStackTrace();  //To change body of catch statement use File | Settings | File Templates.
//            }


            return doc;

        } catch (ParserConfigurationException pce) {
            // Parser with specified options can't be built
            pce.printStackTrace();

        }
        return null;
    }

    private static synchronized Element iterateElementTableRows(Document doc, Element item, Table elements, Table attributes) {
        try {
            if (elements != null) {
                for (int i = 0; i < elements.getRowCount(); i++) {
                    String elementId = elements.getString("ELEMENT_ID", i);
                    String elementName = elements.getString("ELEMENT_NAME", i);
                    String elementText = elements.getString("ELEMENT_TEXT", i);
                    String elementParentId = elements.getString("ELEMENT_PARENT_ID", i);
                    System.out.println("elementId = " + elementId);
                    Table childElements = getChildElements(elements, elementId);
                    if (item == null) {
                        item = doc.createElement(elementName);

                    } else {
                        item.appendChild(doc.createElement(elementName));
                    }

                    //Append Text Node
                    item.appendChild(doc.createTextNode(elementText));

                    //Add Attributes
                    Table attribs = getElementAttributes(attributes, elementId);
                    for (int j = 0; j < attribs.getRowCount(); j++) {
                        item.setAttribute(attribs.getString("ATTRIB_NAME", j), attribs.getString("ATTRIB_VALUE", j));
                    }


                    if (childElements != null) iterateElementTableRows(doc, item, childElements, attributes);
                }

            }
        } catch (Exception e) {
            e.printStackTrace();  //To change body of catch statement use File | Settings | File Templates.
        }
        return item;
    }

    private static synchronized Table getChildElements(Table elements, String elementId) {
        Table childElements = TableUtils.select(elements,
                new String[]{"ELEMENT_ID", "ELEMENT_NAME", "ELEMENT_TEXT", "ELEMENT_PARENT_ID"},
                new String[]{"ELEMENT_PARENT_ID=" + elementId});
        return childElements;
    }

    private static synchronized Table getElementAttributes(Table attributes, String elementId) {
        Table childElements = TableUtils.select(attributes,
                new String[]{"ELEMENT_ID", "ATTRIB_NAME", "ATTRIB_VALUE"},
                new String[]{"ELEMENT_ID=" + elementId});
        return childElements;
    }

    public static synchronized Document createDocumentInstance() throws ParserConfigurationException {
        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
        DocumentBuilder builder = factory.newDocumentBuilder();
        // Create document instance ...
        Document documnet = builder.newDocument();
        return documnet;
    }
/*
    public static void main(String[] args) {

        //String str = FileUtils.readStringFromFile("C:\\wdir\\jLab\\DocumentMill\\src\\java\\menu1.xml");
        String str = FileUtils.readStringFromFile("c:\\wdir\\jLab\\DocumentMill\\src\\java\\resources\\table.xml");

        DomIterator di = new DomIterator(BasicDom.parseXml(str, "", false));

        Table elements = di.getElementTable();
        System.out.println("elements = " + elements);

        Table attributes = di.getAttributeTable();
        System.out.println("attributes = " + attributes);

        Document doc = BasicDom.loadFromTable(elements, attributes);
        System.out.println("doc = " + doc.getDocumentElement());
    }
    */
}
//ElementAdapter//////////////////////////////////////////////////////////////////

import java.io.Serializable;

import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.NamedNodeMap;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;

public class ElementAdapter implements Serializable{
    private Element element;
    private int id = 0;
    private int parentId = -1;
    private int level = 0;
    private String identVal = "\t";


    public ElementAdapter(Element element) {
        this.element = element;
        setLevel();
    }

    public ElementAdapter(Element element, int id, int parentId) {
        this.element = element;
        this.id = id;
        this.parentId = parentId;
        setLevel();
    }

    public ElementAdapter(Element element, int id) {
        this.element = element;
        this.id = id;        
        setLevel();
    }
    
    public int getId() {
        return id;
    }

    public int getParentId() {
        return parentId;
    }

    public Element getElement() {
        return element;
    }

    public Document getOwnerDocument() {
        return element.getOwnerDocument();
    }
    
    public String getElementName() {
        return element.getNodeName();
    }

    public void setElement(Element element) {
        this.element = element;
    }

    public String getCDATA() {
        String txt = "";

        if (element.hasChildNodes()) {
            NodeList childNodes = element.getChildNodes();

            if (childNodes != null) {
                for (int j = 0; j < childNodes.getLength(); j++) {
                    if (childNodes.item(j) != null && childNodes.item(j).getNodeType() == Node.CDATA_SECTION_NODE) {
                        txt += childNodes.item(j).getNodeValue();
                    }
                }
            }
        }
        //else return null;
        return txt;
    }

    public String getText() {
        String txt = "";

        if (element.hasChildNodes()) {
            NodeList childNodes = element.getChildNodes();

            if (childNodes != null) {
                for (int j = 0; j < childNodes.getLength(); j++) {
                    if (childNodes.item(j) != null && childNodes.item(j).getNodeType() == Node.TEXT_NODE) {
                        txt +=  childNodes.item(j).getNodeValue();
                    }
                }
            }
        }
        //else return null;
        return txt;
    }

    public String getTextAndCDATA() {
        String txt = "";

        if (element.hasChildNodes()) {
            NodeList childNodes = element.getChildNodes();

            if (childNodes != null) {
                for (int j = 0; j < childNodes.getLength(); j++) {
                    if (childNodes.item(j) != null && childNodes.item(j).getNodeType() == Node.CDATA_SECTION_NODE ) {
                        txt += childNodes.item(j).getNodeValue();
                    }
                    
                    if (childNodes.item(j) != null && childNodes.item(j).getNodeType() == Node.TEXT_NODE ) {
                        txt += childNodes.item(j).getNodeValue();                     
                    }
                }
            }
        }
        //else return null;
        return txt;
    }

    public String getAttrVal(String name) {
        return element.getAttribute(name);
    }

    public int getLevel() {

        return level;
    }

    public void setLevel() {

        Node temp = element;
        if (temp == null) return;
        while ((temp = temp.getParentNode()) != null) {
            if (temp.getNodeType() == Node.ELEMENT_NODE) level++;
        }

    }

    public String getIdentVal() {
        return identVal;
    }

    public void setIdentVal(String identVal) {
        this.identVal = identVal;
    }
//
//    public String getPath() {
//        String retVal = "/" + element.getNodeName();
//        Node temp = element;
//        if (temp == null) return "";
//        while ((temp = temp.getParentNode()) != null) {
//            if (temp.getNodeType() == Node.ELEMENT_NODE)
//                retVal = "/" + temp.getNodeName() + retVal;
//        }
//        return retVal;
//    }

    public String getXPath() {
        String retVal = "/" + element.getNodeName() + "[" + getElementSiblingIndex(element) + "]";
        Node temp = element;
        if (temp == null) return "";
        while ((temp = temp.getParentNode()) != null) {
            if (temp.getNodeType() == Node.ELEMENT_NODE)
                retVal = "/" + temp.getNodeName() + "[" + getElementSiblingIndex((Element) temp) + "]" + retVal;
        }
        return retVal;
    }

    public int getElementSiblingIndex(Element e) {
        Node sibling = e.getPreviousSibling();
        int elementIdx = 1;

        while (sibling != null) {
            if (sibling.getNodeType() == Node.ELEMENT_NODE && sibling.getNodeName().equals(e.getNodeName())) {
                elementIdx++;
            }
            sibling = sibling.getPreviousSibling();
        }
        return elementIdx;
    }

    public String attributesToString() {
        String retVal = "";
        NamedNodeMap attrMap = element.getAttributes();
        for (int i = 0; i < attrMap.getLength(); i++) {
            Node attr = attrMap.item(i);
            String attrName = attr.getNodeName();
            String attrValue = getAttrVal(attrName);
            retVal = retVal + attrName + "=\"" + attrValue + "\" ";
        }
        return retVal;
    }

    public String getIdent() {
        int i = getLevel();
        StringBuffer sb = new StringBuffer("");
        while (i-- > 0) sb.append(identVal);
        return sb.toString();
    }

    public String toString() {
        return "ElementAdapter{" +
                "element=" + element +
                ", id=" + id +
                ", parentId=" + parentId +
                "}";
    }
    

//    public static String encode(String str){
//    	return str.replaceAll("<","&lt;").replaceAll(">","&gt;").replaceAll("\"","&quot;");
//    }
    
//    public static String decode(String str){
//    	return str.replaceAll("&lt;","<").replaceAll("&gt;",">").replaceAll("&quot;","\"");
//    }
}

////////////////////////////////////////////////////////////////////
	/**
	 * REST API: /download
	 * 
	 * @param fileDetailsId
	 * @param response
	 * @throws IOException
	 */
	@RequestMapping(value = "/v1/downloadFile", method = RequestMethod.GET, produces = { "application/octet-stream" })
	public void downloadFile(@RequestParam(value = "fileDetailsId", required = true) Long fileDetailsId,
			@Context HttpServletResponse response, HttpServletRequest request) throws IOException {

		recordLogging(request, true, JsonUtil.toJson(request.getParameterMap()));
		FileDetails fileDetails1 = fileDetailsRepository.findOne(fileDetailsId);

		response.setContentLength(fileDetails1.getFileContent().length);
		response.setHeader("Content-Disposition", "attachment; filename=" + fileDetails1.getFileName());

		ServletOutputStream outStream = response.getOutputStream();
		InputStream in = new ByteArrayInputStream(fileDetails1.getFileContent());

		try {
			byte[] bbuf = new byte[1024];
			int length = 0;
			while ((in != null) && ((length = in.read(bbuf)) != -1)) {
				outStream.write(bbuf, 0, length);
			}

		} catch (Exception e) {
			recordError(request, false, e);
		} finally {
			in.close();
			outStream.flush();
		}
		recordLogging(request, false, "");
	}

	/**
	 * REST API: /upload
	 * 
	 * @param requestId
	 * @param fileTypes
	 * @param files
	 * @return
	 * @throws Exception
	 */
	@RequestMapping(value = "/v1/uploadFile", method = RequestMethod.POST)
	public @ResponseBody Boolean uploadFile(@RequestParam(value = "requestId", required = true) Long requestId,
			@RequestParam(value = "fileType", required = true) String[] fileTypes,
			@RequestParam(value = "file", required = true) MultipartFile[] files, HttpServletRequest request) throws Exception {

		if (fileTypes != null && files != null && fileTypes.length != files.length)
			throw new Exception("Number of fileType parameters and file parameters has to be the same!");

		WorkflowRequest wfr = workflowRequestRepository.findOne(requestId);
		List<FileDetails> fileDetailsList = new ArrayList<FileDetails>();
		for (int i = 0; i < files.length; i++) {
			
			try //Validate attachment files
			{
				validateFile(files[i]);

			} catch (ExceptionResponse er)
			{
				recordError(request, false, er);
				throw er;
			}
			
			FileDetails fileDetails = new FileDetails();
			fileDetails.setFileName(files[i].getOriginalFilename());
			fileDetails.setFileType(fileTypes[i]);
			fileDetails.setRequestDetails(wfr.getRequestDetails());
			fileDetails.setFileContent(files[i].getBytes());
			fileDetailsList.add(fileDetails);

		}

		fileDetailsRepository.save(fileDetailsList);

		return true;
	}



///////////////////////////////////////////////////////////////////////////////
@RequestMapping(value = "/downloadFile", method = RequestMethod.GET, produces =
	{ "application/octet-stream" })
	public void downloadFile(@RequestParam(value = "fileDetailsId", required = true) Long fileDetailsId,
			@Context HttpServletResponse response, HttpServletRequest request)
			throws IOException, RestClientException, CarpException
	{
		recordLogging(request, true, JsonUtil.toJson(request.getParameterMap()));
		
		String url = restConfig.getAccessUrl() + restConfig.getCarpservicesUri() + "/v1/downloadFile?fileDetailsId="
				+ fileDetailsId;
		LOGGER.info(url);

		HttpHeaders headers = new HttpHeaders();
		headers.setAccept(Arrays.asList(MediaType.APPLICATION_OCTET_STREAM));

		ResponseEntity<byte[]> responseEntity = getRestTemplate(request).exchange(url, HttpMethod.GET,
				new HttpEntity(headers), byte[].class, "1");

		HttpHeaders respHeaders = responseEntity.getHeaders();

		response.setContentLength(responseEntity.getBody().length);

		response.setHeader("Content-Disposition", respHeaders.get("Content-Disposition").get(0));

		ServletOutputStream outStream = response.getOutputStream();

		InputStream in = new ByteArrayInputStream(responseEntity.getBody());

		try
		{
			byte[] bbuf = new byte[1024];
			int length = 0;
			while ((in != null) && ((length = in.read(bbuf)) != -1))
			{
				outStream.write(bbuf, 0, length);
			}

			recordLogging(request, false, "");
		} catch (Exception e)
		{
			recordError(request, false, e);
			
		} finally
		{
			in.close();
			outStream.flush();
		}
	}

	/**
	 * REST API: /upload
	 * 
	 * @param requestId
	 * @param fileTypes
	 * @param files
	 * @return
	 * @throws Exception
	 */
	@RequestMapping(value = "/uploadFile", method = RequestMethod.POST)
	public @ResponseBody Boolean uploadFile(@RequestParam(value = "requestId", required = true) Long requestId,
			@RequestParam(value = "fileType", required = true) String[] fileTypes,
			@RequestParam(value = "file", required = true) MultipartFile[] files, HttpServletRequest request)
			throws Exception
	{
		recordLogging(request, true, JsonUtil.toJson(request.getParameterMap()));
		
		String url = restConfig.getAccessUrl() + restConfig.getCarpservicesUri() + "/v1/uploadFile";
		LOGGER.info(url);

		MultiValueMap<String, Object> map = new LinkedMultiValueMap<String, Object>();
		map.add("requestId", requestId);

		for ( int i = 0 ; i < fileTypes.length ; i++ )
		{
			map.add("fileType", fileTypes[i]);
		}

		for ( int i = 0 ; i < files.length ; i++ )
		{
			map.add("file", new FileMessageResource(files[i].getBytes(), files[i].getOriginalFilename()));
		}

		HttpEntity<LinkedMultiValueMap<String, Object>> requestEntity = new HttpEntity<LinkedMultiValueMap<String, Object>>(
				(LinkedMultiValueMap<String, Object>) map);
		Boolean result = getRestTemplate(request).postForObject(url, requestEntity, Boolean.class);
		result = (result == null) ? new Boolean(false) : result;
		recordLogging(request, false, JsonUtil.toJson(result));
		return result;
		

	}
	


///////////////////////////////////////////////////////////////
import org.springframework.core.io.ByteArrayResource;

/**
 * @author drapig3 - Nov. 2016
 *
 */
public class FileMessageResource extends ByteArrayResource
{

	/**
	 * The filename to be associated with the file data.
	 */
	private final String filename;

	public FileMessageResource(final byte[] byteArray, final String filename)
	{
		super(byteArray);
		this.filename = filename;
	}

	@Override
	public String getFilename()
	{

		return filename;
	}
}

////////////////////////////////////////////////////////////////////
		ServletOutputStream outStream = null;

		InputStream in = null;

		try
		{
			HttpHeaders headers = new HttpHeaders();
			headers.setAccept(Arrays.asList(MediaType.APPLICATION_OCTET_STREAM));

			ResponseEntity<byte[]> responseEntity = getRestTemplate(request).exchange(url, HttpMethod.POST,
					new HttpEntity(reportApprovedReq, headers), byte[].class, "1");

			HttpHeaders respHeaders = responseEntity.getHeaders();

			response.setContentLength(responseEntity.getBody().length);
			response.setHeader("@RequestMapping(value = "/submitDataAccessWorkflowRequest", method = RequestMethod.POST)
	public @ResponseBody ResponseEntity submitDataAccessWorkflowRequest(
			@RequestParam(value = "workflowRequest", required = true) String workflowRequestStr,
			@RequestParam(value = "piaFile", required = false) MultipartFile piaFile,
			@RequestParam(value = "otherFile4", required = false) MultipartFile otherFile4,
			@RequestParam(value = "otherFile1", required = false) MultipartFile otherFile1,
			@RequestParam(value = "otherFile2", required = false) MultipartFile otherFile2,
			@RequestParam(value = "otherFile3", required = false) MultipartFile otherFile3, HttpServletRequest request)
			throws IOException, CarpException
	{
		recordLogging(request, true, JsonUtil.toJson(request.getParameterMap()));
		
		String url = restConfig.getAccessUrl() + restConfig.getCarpservicesUri()
				+ "/v1/submitDataAccessWorkflowRequest";
		LOGGER.info(url);

		MultiValueMap<String, Object> map = new LinkedMultiValueMap<String, Object>();

		map.add("workflowRequest", workflowRequestStr);

		if ( piaFile != null )
		{
			map.add("piaFile", new FileMessageResource(piaFile.getBytes(), piaFile.getOriginalFilename()));
		}
		if ( otherFile4 != null )
		{
			map.add("otherFile4", new FileMessageResource(otherFile4.getBytes(), otherFile4.getOriginalFilename()));
		}
		if ( otherFile1 != null )
		{
			map.add("otherFile1", new FileMessageResource(otherFile1.getBytes(), otherFile1.getOriginalFilename()));
		}
		if ( otherFile2 != null )
		{
			map.add("otherFile2", new FileMessageResource(otherFile2.getBytes(), otherFile2.getOriginalFilename()));
		}
		if ( otherFile3 != null )
		{
			map.add("otherFile3", new FileMessageResource(otherFile3.getBytes(), otherFile3.getOriginalFilename()));
		}

		HttpEntity<LinkedMultiValueMap<String, Object>> requestEntity = new HttpEntity<LinkedMultiValueMap<String, Object>>(
				(LinkedMultiValueMap<String, Object>) map);

		//Boolean result =  getRestTemplate(request).postForObject(url, requestEntity, Boolean.class);
		//return result==null?new Boolean(false):result;
		ResponseEntity resp =  getRestTemplate(request).exchange(url, HttpMethod.POST, requestEntity,
				new ParameterizedTypeReference<ResponseDetails<Boolean>>()
				{
				});
		
		recordLogging(request,false,JsonUtil.toJson(resp==null?null:resp.getBody()));
		return resp;
	}Content-Disposition", respHeaders.get("Content-Disposition").get(0));

			//			response.setContentType("txt/csv");
			//			response.addHeader(name, value);

			outStream = response.getOutputStream();

			in = new ByteArrayInputStream(responseEntity.getBody());

			byte[] bbuf = new byte[1024];
			int length = 0;
			while ((in != null) && ((length = in.read(bbuf)) != -1))
			{
				outStream.write(bbuf, 0, length);
			}

		} catch (Exception e)
		{
			//	        e.printStackTrace();
		} finally
		{
			try
			{
				if ( outStream != null )
					outStream.flush();
				if ( in != null )
					in.close();
			} catch (IOException e)
			{
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		}
