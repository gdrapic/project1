
import java.util.Vector;
import java.util.regex.Matcher;
import java.util.regex.Pattern;


public class StreamEditor {

    // Substitution syntax
    //[address]s/pattern/replacement/flags
    private static final Pattern sedExprPattern =
            Pattern.compile("(?s)([^\\\\])/(.*[^\\\\])/(.*[^\\\\]?)/(.+)");

    private static final Pattern grpRefPattern =
            Pattern.compile("\\\\(\\d+)");

    private static final Pattern origStrPattern =
            Pattern.compile("[^\\\\](&)");


    public StreamEditor() {
    }

    /**
     * Replace first instance of the /pattern/
     *
     * @param strBuff     originam string
     * @param regexpr     pattern
     * @param replacement
     * @return modified string
     */
    public static StringBuffer replace(StringBuffer strBuff, String regexpr,
                                       String replacement) {
        return replace(strBuff, regexpr, replacement, "1");
    }

    /**
     * Replace nth instance of the /pattern/
     *
     * @param strBuff     - originam string
     * @param pattern
     * @param replacement
     * @param n           n - [1-9]* or ([0-9]+) Replace nth instance of /pattern/<br>
     *                    g - (global) Replace all instances of the /pattern/
     * @return modified string
     */
    public static StringBuffer replace(StringBuffer strBuff, String pattern,
                                       String replacement,
                                       String n) {
        Pattern p = Pattern.compile(pattern);
        Matcher m = p.matcher(strBuff);
        StringBuffer sb = new StringBuffer();
        int count = 0;
        while (m.find()) {
            count++;
            if ((count < 10 && n.indexOf("" + count) > -1) ||
                    n.indexOf("(" + count + ")") > -1 ||
                    n.indexOf("g") > -1) {
                m.appendReplacement(sb, replacement);
            }
        }
        m.appendTail(sb);
        //System.out.println(sb);
        return sb;
    }

    public static String strEdit(String str, String sExpression) {
        //System.out.println("str:>>" + str + "<<");
        //System.out.println("bool: " +
        //                   sedExprPattern.matcher(sExpression).matches()  );

        StringBuffer strBuff = new StringBuffer(str);
        StringBuffer sb = new StringBuffer();

        //Validate and prse sExpression
        //and extract sed expression elements
        Matcher sm = sedExprPattern.matcher(sExpression);
        sm.reset();
        if (sm.find(0)) {

            String cmd = sm.group(1);
            //System.out.println("cmd: " + cmd);

            String pattern = sm.group(2);
            //System.out.println("pattern: " + pattern);

            String replacement = sm.group(3);
            //System.out.println("replacement: " + replacement);

            String flags = sm.group(4);
            //System.out.println("flags: " + flags);

            ///////////////////////////////////////////
            //Process stream
            //===================================
            Pattern p = Pattern.compile(pattern);
            //===================================

            Matcher m = p.matcher(strBuff);
            int count = 0;
            while (m.find()) {
                count++;
                if ((count < 10 && flags.indexOf("" + count) > -1) ||
                        flags.indexOf("(" + count + ")") > -1 ||
                        flags.indexOf("g") > -1) {
                    m.appendReplacement(sb,
                            prepareReplacement(m, replacement, str));
                }
            }
            m.appendTail(sb);
        } else {
            System.out.println("Error in sed expression formatting!");
            System.out.println("sExpression:>>" + sExpression + "<<");
            return str;
        }
        return sb.toString();

    }

    /**
     * @param str   String to be modified
     * @param sArgs command/pattern/replacement/[flags]<br>
     *              command:<br>
     *              s - substitute (only implemented command for now, gdrapic 2003/04/30)<br>
     *              flags:<br>
     *              n - "[1-9]*" or "([0-9]+)*" Replace nth instance of /pattern/. Default value is 1<br>
     *              g - (global) - Replace all instances of the /pattern/<br>
     *              flags examples: 24(12)(17) - replaces 2nd, 4th, 12th and 17th occurance of the pattern <br><br>
     *              sed Examples:<br>
     *              1) sed("1a-2a-3a-4a-5a-6a-7a-8a-9a-10a-11a-12a-13a-14a-15a-16a-17a-18a-19a-20a",<br>
     *              "s/a/b/14(12)(14)");<br> replaces: 1st, 4th 12th and 14th instance<br>
     *              OUTPUT: 1b-2b-3a-4b-5a-6a-7a-8a-9a-10a-11a-12b-13a-14b-15a-16a-17a-18a-19a-20a
     * @return modified str
     */
    public static synchronized String sed(String str, String sArgs) {
        // sArgs ="sedExpr1 -e [sedExpr2]  ... [-e sedExprN]";
        // sed(str, sArgs);

        try {
            sArgs = sArgs.replaceAll("\\s", " ");
            String[] exps = sArgs.split(" +-e +");
            for (int i = 0; i < exps.length; i++) {
            	if(exps[i]!=null && !exps[i].trim().equals("")){
            		str = strEdit(str, exps[i]);
            	}
            }
        } catch (Exception ex) {
            ex.printStackTrace();
            return null;
        }
        return str;
    }

    private static String prepareReplacement(Matcher m,
                                             String replacement,
                                             String str) {

        Matcher grpRefMatch = grpRefPattern.matcher(replacement);

        StringBuffer sbReplacement = new StringBuffer();
        while (grpRefMatch.find()) {
            String r = m.group(Integer.parseInt(grpRefMatch.group(1)));
            grpRefMatch.appendReplacement(sbReplacement, r);
        }
        grpRefMatch.appendTail(sbReplacement);

        // Substitutes '&' by original string 'str' NOTE: capture original
        // string and keep it unchanged to the end of the substitution.
        Matcher ma = origStrPattern.matcher(sbReplacement);

        Vector endIdxs = new Vector();
        while (ma.find()) {
            endIdxs.add(new Integer(ma.end()));
        }

        int endIdx;
        for (int i = endIdxs.size() - 1; i > -1; i--) {
            endIdx = ((Integer) endIdxs.get(i)).intValue();
            sbReplacement = sbReplacement.replace(endIdx - 1, endIdx, str);
        }

        return sbReplacement.toString();
    }

    public static void main(String[] args) {
        StreamEditor streamEditor1 = new StreamEditor();
        System.out.println("StreamEditor.sed(\"boo:and:foo:\",\"s/:/-/2\") \n>> output: " +
                StreamEditor.sed("boo:and:foo:", "s/:/-/2"));

        System.out.println(sed("1a-2a-3a-4a-5a-6a-7a-8a-9a-10a-11a-12a-13a-14a-15a-16a-17a-18a-19a-20a",
                "s/a/b/14(12)(14)"));
        System.out.println(sed("1a-2a-3a-4a-5a-6a-7a-8a-9a-10a-11a-12a-13a-14a-15a-16a-17a-18a-19a-20a",
                "s/(.)\\d+/:letter \\1, >>&<</g"));

        String htmlSrc = "some text <a HREF=\"/tfl/home.cfm\">link</a> \n" +
                "some another text <a href=\"/tfl/home.cfm\">second link</a> \n" +
                "some text <img src=\"/tfl/home.cfm\">link</a> \n";

        System.out.println("htmlSrc:\n" + htmlSrc);
        System.out.println("sedExpr: " +
                "s/(?si)(href|src)=.\\/tfl/\\1=\"http:\\/\\/www.library.com\\/tfl/g");
        System.out.println("output: \n" +
                StreamEditor.sed(htmlSrc,
                        "s/(?si)(href|src)=.\\/tfl/\\1=\"http:\\/\\/www.fundlibrary.com\\/tfl/g"));
        System.out.println(ReUtils.isMatching("some text <a href=\"/tfl/home.cfm\">link</a> ",
                "(.*<a href=\\\")(\\/tfl\\/)(home.cfm.*)"));

        String sExpr = "s/(?si)(.*)<tbody><tr><td>(.*)<\\/td><td>(.*)<\\/td><td>(.*)<\\/td><\\/tr><\\/tbody>(.*)/ A: \\2 | B: \\3 | C: \\4 /g";

    }
}
/////////////////////////////////////////////////////////
import java.io.File;

// Depth first search of DOM Tree

public abstract class SimpleFileIterator {
    int level = 0;

    public int getLevel() {
        return level;
    }

    // note use of recursion
    public void followFile(File file) throws Exception {

        if (!isSelected(file)) return;


        processFile(file);

        if (file.listFiles() != null) {
            level++;
            File[] files = file.listFiles();
            for (int i = 0; i < files.length; i++) {
                followFile(files[i]);
            }
            level--;
        }

        postProcessFile(file);

    }

    // Override this method to apply selection criteria
    protected boolean isSelected(File file) {
        return true;
    }

    // Implement this methods to do something as each file is visited
    protected abstract void processFile(File file) throws Exception;

    protected abstract void postProcessFile(File file) throws Exception;

}


////////////////////////////////////////////////////////////////
import java.io.File;
import java.text.SimpleDateFormat;
import java.util.Date;

// Depth first search of DOM Tree

public abstract class FileFilter extends SimpleFileIterator {

    private String[] addRe;
    private String[] skipRe;

    private File[] files;
    private File[] roots;
    private int currRootIdx;
    private long fIdx = 0;

    protected FileFilter(String file) {
        this(new File(file));
    }

    protected FileFilter(File file) {
        this(new File[]{file});
    }

    protected FileFilter(String[] files) {
        File[] fileArr = new File[files.length];
        for (int i = 0; i < fileArr.length; i++) {
            fileArr[i] = new File(files[i]);
        }

        this.files = fileArr;
    }

    protected FileFilter(File[] files) {
        this.files = files;
    }

    public void apply() throws Exception {
        init();
        roots = new File[files.length];
        for (int i = 0; i < files.length; i++) {
            currRootIdx = i;
            roots[i] = files[i].isDirectory()?files[i]:files[i].getParentFile();
            followFile(files[i]);
        }
        release();
    }

    public void init() throws Exception{
        //Overwrite this method
    }

    public void release() throws Exception{
        //Overwrite this method
    }

    protected boolean isSelected(File file) {

        if (skipRe != null) {
            for (int i = 0; i < skipRe.length; i++) {
                String re = skipRe[i];
                if (re!=null && re.trim().length()>0 && file.getPath().matches(re)) return false;
            }
        }

        if (addRe != null && addRe.length > 0 && !file.isDirectory()) {
            boolean retVal = false;
            for (int i = 0; i < addRe.length; i++) {
                String re = addRe[i];
                if (re!=null
                        //&& re.trim().length()>0
                        ) {
                    retVal = retVal || file.getPath().matches(re);
                }
            }
            return retVal;
        }

        return true;
    }

    public String[] getAddRe() {
        return addRe;
    }

    public void setAddRe(String[] addRe) {
        this.addRe = addRe;
    }

    public String[] getSkipRe() {
        return skipRe;
    }

    public void setSkipRe(String[] skipRe) {
        this.skipRe = skipRe;
    }

    String identStr = "\t";

    public String getIdent() {
        int i = getLevel();
        StringBuffer sb = new StringBuffer("");
        while (i-- > 0) sb.append(identStr);
        return sb.toString();
    }

    public String trimRoot(File file){
        String trimmedRoot = "";
        if (file.getPath().indexOf(getCurrentRoot().getPath()) > -1) {
            trimmedRoot = file.getPath().length()>getCurrentRoot().getPath().length()?file.getPath().substring(getCurrentRoot().getPath().length() + 1):file.getPath().substring(getCurrentRoot().getPath().length());
        }

        return trimmedRoot;
    }

    public static File setTimestamp(File file) {
        SimpleDateFormat yyyyMMddHHmmss = new SimpleDateFormat("yyyyMMddHHmmss");
        StringBuffer sb = new StringBuffer();
        if (file != null) {
            String filePath = file.getPath();
            sb = new StringBuffer(file.getPath());
            sb.replace(filePath.lastIndexOf("."),
                    filePath.lastIndexOf("."),
                    "." + yyyyMMddHHmmss.format(new Date()));
        }
        return new File(sb.toString());
    }

    public int getCurrRootIdx() {
        return currRootIdx;
    }

    public void setCurrRootIdx(int currRootIdx) {
        this.currRootIdx = currRootIdx;
    }

    public long getFIdx() {
        return fIdx;
    }

    public String getIdentStr() {
        return identStr;
    }

    public void setIdentStr(String identStr) {
        this.identStr = identStr;
    }

    public File getCurrentRoot() {
        return roots[currRootIdx];
    }

    public File[] getRoots() {
        return roots;
    }

    public void setRoots(File[] roots) {
        this.roots = roots;
    }
}

////////////////////////////////////////////////////////////
import java.io.File;

import utils.regex.StreamEditor;


public class Substitute extends FileFilter {

    String expression = "";
    boolean mkdirs = false;
    boolean verbose = false;
    boolean overwrite = false;

    File destDir;

    public Substitute(String file, String expression, String destDir) {
        super(file);
        this.expression = expression;
        this.destDir = new File(destDir);
    }

    public Substitute(File file,  String expression, File destDir) {
        super(file);
        this.expression = expression;
        this.destDir = destDir;
    }

    public Substitute(String[] files, String expression, String destDir) {
        super(files);
        this.expression = expression;
        this.destDir = new File(destDir);
    }

    public Substitute(File[] files,  String expression, File destDir) {
        super(files);
        this.expression = expression;
        this.destDir = destDir;
    }

    public boolean isMkdirs() {
		return mkdirs;
	}

	public void setMkdirs(boolean mkdirs) {
		this.mkdirs = mkdirs;
	}

	public boolean isVerbose() {
		return verbose;
	}

	public void setVerbose(boolean verbose) {
		this.verbose = verbose;
	}
	
	public boolean isOverwrite() {
		return overwrite;
	}

	public void setOverwrite(boolean overwrite) {
		this.overwrite = overwrite;
	}

	// Implement this methods to do something as each file is visited
    protected void processFile(File file) {
        if (file.isDirectory()) return;
        if (file.exists() && !overwrite) return;
        String str = new TextFile(file.getPath()).getContent();

        str = StreamEditor.sed(str,expression);

        String destFilePath = "";
        if (file.getPath().indexOf(getCurrentRoot().getPath()) > -1) {
            String trimmedRoot = file.getPath().substring(getCurrentRoot().getPath().length());
            destFilePath =  destDir.getPath() +  File.separator + trimmedRoot;
            new TextFile(destFilePath, mkdirs).print(str, false);
        } else {
            // TODO:Throw exception !!!!!
            //destFilePath = destDir + sed(f.toString(), "s/^.://g");
        }
        if ( verbose ) System.out.println("File: " + file);
    }

    protected void postProcessFile(File file) {
        //
    }

    public static void main(String[] args) throws Exception {
        String[] addRe = {"^.*\\.html$", "^.*\\.htm$"};
        String[] skipRe = {"^.*bak$", "^.*CVS$"};

        Substitute subst = new Substitute(
                "c:\\wdir\\",
                
                        "-e s/SiteBuilder\\/2.0.3\\/1.4.1_03/DocumentMill 2.05/g" +
                        " -e s/\\<\\!--\\$.*\\$--\\>//g" +
                        " -e s/<base href\\=\\\".*>//g" +
                        " -e s/sitebuilder\\///g" +
                        " -e s/preview\\///g"
                        ,
                "c:/deployables"
        );
        subst.setAddRe(addRe);
        subst.setSkipRe(skipRe);
        subst.apply();

    }
}


///////////////////////////////////////////////////////////////
import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.zip.CRC32;
import java.util.zip.CheckedOutputStream;
import java.util.zip.ZipEntry;
import java.util.zip.ZipOutputStream;

public class ZipFile extends File {

    private int level = 0;

    //internall processing
    private File[] roots;
    private int currRootIdx;
    private long fIdx = 0;

    //Constructor fields
    File[] files;

    //Switches
    private String[] addRe;
    private String[] skipRe;

    private boolean verbose = false;
    private boolean makedirs = false;
    private boolean fullPaths = false;

    //Zip processing
    private static final int BUFFER = 2048;
    private byte data[] = new byte[BUFFER];
    private FileInputStream fi = null;
    private BufferedInputStream origin = null;
    private FileOutputStream dest = null;
    private CheckedOutputStream checksum = null;
    private ZipOutputStream out = null;

    public ZipFile(String zipPathname, String[] files) {
        this(zipPathname, files, false);
    }

    public ZipFile(String zipPathname, String file) {
        this(zipPathname, new String[]{file});
    }

    public ZipFile(String zipPathname, String[] files, boolean timestamp) {
        super(timestamp ? setTimestamp(zipPathname) : zipPathname);
        this.files = new File[files.length];
        for (int i = 0; i < files.length; i++) {
            this.files[i] = new File(files[i]);
        }
    }

    //Public block
    //Getters & Setters
    public String[] getAddRe() {
        return addRe;
    }

    public void setAddRe(String[] addRe) {
        this.addRe = addRe;
    }

    public String[] getSkipRe() {
        return skipRe;
    }

    public void setSkipRe(String[] skipRe) {
        this.skipRe = skipRe;
    }

    public boolean isVerbose() {
        return verbose;
    }

    public void setVerbose(boolean verbose) {
        this.verbose = verbose;
    }

    public boolean isMakedirs() {
        return makedirs;
    }

    public void setMakedirs(boolean makedirs) {
        this.makedirs = makedirs;
    }

    public boolean isFullPaths() {
        return fullPaths;
    }

    public void setFullPaths(boolean fullPaths) {
        this.fullPaths = fullPaths;
    }


    public File create() {
        try {
            if (verbose) System.out.println("Creating: " + this.getAbsolutePath());
            if (makedirs) getParentFile().mkdirs();
            dest = new FileOutputStream(this);
            //checksum = new CheckedOutputStream(dest, new Adler32());
            checksum = new CheckedOutputStream(dest, new CRC32());
            out = new ZipOutputStream(new BufferedOutputStream(checksum));
            //out.setMethod(ZipOutputStream.DEFLATED);
            roots = new File[files.length];
            for (int i = 0; i < files.length; i++) {
                currRootIdx = i;

                roots[i] = files[i].getParentFile();

                followFile(files[i]);
            }
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            release();
        }
        return this;
    }

    //Private block

    // note use of recursion
    private void followFile(File file) {

        if (!isSelected(file)) return;

        processFile(file);

        if (file.listFiles() != null) {
            level++;
            File[] files = file.listFiles();
            for (int i = 0; i < files.length; i++) {
                followFile(files[i]);
            }
            level--;
        }

        postProcessFile(file);

    }

    ///////////////////////////////////////////////
    //internall processing
    ///////////////////////////////////////////////
    private boolean isSelected(File file) {

        if (skipRe != null) {
            for (int i = 0; i < skipRe.length; i++) {
                String re = skipRe[i];
                if (file.getPath().matches(re)) return false;
            }
        }

        if (addRe != null && addRe.length > 0 && !file.isDirectory()) {
            boolean retVal = false;
            for (int i = 0; i < addRe.length; i++) {
                String re = addRe[i];
                retVal = retVal || file.getPath().matches(re);
            }
            return retVal;
        }

        return true;
    }

    private void processFile(File file) {
        fIdx++;
        try {

            String zipEntry = file.toString();

            if (!fullPaths) {
                if (roots[currRootIdx] != null && roots[currRootIdx].getPath().endsWith(File.separator)) {
                    zipEntry = file.toString().substring(roots[currRootIdx].getPath().length());
                } else {
                    zipEntry = file.toString().substring(roots[currRootIdx].getPath().length() + 1);
                }
            }

            if (file.isDirectory()) {
            	zipEntry = zipEntry + File.separator;
            }

            
            ZipEntry entry = new ZipEntry(zipEntry);
            out.putNextEntry(entry);
            
            if (!file.isDirectory()) {
            	fi = new FileInputStream(file);
                origin = new BufferedInputStream(fi, BUFFER);
                int count;
                while ((count = origin.read(data, 0, BUFFER)) != -1) {
                    out.write(data, 0, count);
                }
            }
            
            out.closeEntry();

        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    private void postProcessFile(File file) {
        if (verbose) System.out.println("+ " + file);
    }

    private void release() {
        if (checksum != null && verbose) System.out.println("checksum:" + checksum.getChecksum().getValue());
        try {
            fi.close();
            origin.close();
            out.close();
            dest.close();
        } catch (Exception ex) {
            //
        }
    }

    //Utility methods
    public static String setTimestamp(String fileName) {
        if (!fileName.matches(".*\\.[^\\.]*$")) return fileName;
        SimpleDateFormat yyyyMMddHHmmss = new SimpleDateFormat("yyyyMMddHHmmss");
        StringBuffer sb = null;
        if (fileName != null) {
            sb = new StringBuffer(fileName);
            sb.replace(fileName.lastIndexOf("."),
                    fileName.lastIndexOf("."),
                    "." + yyyyMMddHHmmss.format(new Date()));
        }
        return sb.toString();
    }

    public static String getArgVal(String arg) {
        Pattern paramPattern = Pattern.compile("[a-zA-Z0-9]+=(\"?)(.*)\\1");
        Matcher m = paramPattern.matcher(arg);
        if (m.find())
            return m.group(2);
        else
            return null;
    }

    /**
     * @param args
     */
    public static void main(String[] args) {

        if (args != null && args.length > 1) {
            String zipFile = null;
            ArrayList fileList = null;
            ArrayList addReList = null;
            ArrayList skipReList = null;

            boolean timestamp = false;
            boolean verbose = false;
            boolean makedirs = false;
            boolean fullPaths = false;

            for (int i = 0; i < args.length; i++) {
                //System.out.println(args[i]);
                String arg = args[i].trim();
                if (arg.startsWith("zip=")) {
                    zipFile = ZipFile.getArgVal(arg);
                    System.out.println(zipFile);
                }
                if (arg.startsWith("file=")) {
                    String file = ZipFile.getArgVal(arg);
                    if (file != null) {
                        if (fileList == null) fileList = new ArrayList();
                        fileList.add(file);
                    }
                    System.out.println(file);
                }

                if (arg.startsWith("add=")) {
                    String add = ZipFile.getArgVal(arg);
                    if (add != null) {
                        if (addReList == null) addReList = new ArrayList();
                        addReList.add(add);
                    }
                    System.out.println(add);
                }

                if (arg.startsWith("skip=")) {
                    String skip = ZipFile.getArgVal(arg);
                    if (skip != null) {
                        if (skipReList == null) skipReList = new ArrayList();
                        skipReList.add(skip);
                    }
                    System.out.println(skip);
                }
                if ("time".equalsIgnoreCase(arg)) timestamp = true;
                if ("verbose".equalsIgnoreCase(arg)) verbose = true;
                if ("mkdirs".equalsIgnoreCase(arg)) makedirs = true;
                if ("fullPaths".equalsIgnoreCase(arg)) fullPaths = true;
            }

            if (zipFile != null && fileList != null && fileList.size() > 0) {
                String[] files = (String[]) fileList.toArray(new String[fileList.size()]);
                ZipFile zip = new ZipFile(zipFile, files, timestamp);

                if (addReList != null) {
                    String[] addRe = (String[]) addReList.toArray(new String[addReList.size()]);
                    zip.setAddRe(addRe);
                }

                if (skipReList != null) {
                    String[] skipRe = (String[]) skipReList.toArray(new String[skipReList.size()]);
                    zip.setSkipRe(skipRe);
                }

//    			Create directories if do not exist
                zip.setMakedirs(makedirs);

//    	      Output the file names to the System.out
                zip.setVerbose(verbose);
                zip.setFullPaths(fullPaths);

                //Finally zip it......
                //if(!zip.exists())
                zip.create();

            }
        } else {
            System.out.println("Example Usage:\n " +
                    "java ZipFile zip=\"C:\\archives\\MyArchive.zip\" " +
                    "file=\"C:\\path\\to\\file\" " +
                    "add=\".*\\.(?i:java)$\" " +
                    "skip=\".*\\\\(?i:CVS)\\\\.*$\" " +
                    "time " +
                    "fullpaths " +
                    "mkdirs");
        }

        System.exit(0);

        //Usage Example:
        //CDS backup ......
        ZipFile zip = new ZipFile(
                "C:\\dev\\archive\\CDS.zip", //ZIP file path & name
                new String[]{
                        //"c:\\path\\to\\some\\dir\\or\\file",
                        "C:\\dev\\CDS",
                }, //array of the files/dirs paths be archived. It could be a single file or directory.
                true //insert timestamp (Example: CDS.200512141638.zip)
        );

        //Apply File Filters		
        //addRe - added files pattern - Regular Expression defines pattern of the file paths to be zipped!
        //Example: addRe=".*\.(?i:xls|txt)$"  >> select Excel and text file types (with ignore case: xls,XLS, Xls ...)
        //NOTE: It does not apply to directory paths!!!
        String[] addRe = {".*\\.(?i:tld|java|jsp|html|htm|js|txt|sh|bat|css|sql|ddl|erl|properties|csv|xml|rpt|jpg|png|gif|dwt|dml)$"};

        //skipRe - skipped files/dirs pattern - Regular Expression !!
        ////Example: skip=".*\\(?i:bak|CVS)\\.*$" >> does not recurse into bak(BAK,Bak,bAk ..) and CVS(cvs,cVs ..) folders
        //NOTE: It applies to file and directory paths!!!
        String[] skipRe = {".*\\\\(?i:CVS)\\\\.*$"};

        zip.setAddRe(addRe);
        zip.setSkipRe(skipRe);

        //Create directories if do not exist
        zip.setMakedirs(true);

//      Output the file names to the System.out
        zip.setVerbose(true);
        zip.setFullPaths(false);

        //Finally zip it......
        if (!zip.exists()) zip.create();

        System.out.println("zip = " + zip);
    }
}
/////////////////////////////////////////////////////////////////////
import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.LineNumberReader;
import java.io.PrintWriter;

public class TextFile extends File {

private static final long serialVersionUID = 5447032761953485418L;


    public TextFile(String path) {
        super(path);
        //this(path,false);
    }

    public TextFile(String path, boolean makedirs) {
        super(path);
        if (makedirs) getParentFile().mkdirs();
    }

    public boolean println(String str) {
        return println(str, true);
    }

    public boolean println(String str, boolean append) {
        PrintWriter out = null;
        try {
            out = new PrintWriter(new FileWriter(this, append), append);
            if (out != null)
                out.println(str);
        } catch (IOException e) {
            System.err.println("ERROR: " + e.getMessage() + " at " + e.getClass());
        } finally {
            if (out != null) out.close();
        }
        return !out.checkError();
    }

    public boolean print(String str) {
        return print(str, true);
    }

    public boolean print(String str, boolean append) {
        boolean retVal = false;
        PrintWriter out = null;

        try {
            out = new PrintWriter(new FileWriter(this, append), append);
            if (out != null) {
                retVal = !out.checkError();
                out.print(str);
            }
        } catch (IOException e) {
            System.out.println("ERROR: " + e.getMessage() + " at " + e.getClass());
        } finally {
            if (out != null) out.close();
        }
        return retVal;
    }

    public LineNumberReader getLineNumberReader() throws FileNotFoundException {
        return new LineNumberReader(new FileReader(this));
    }

    public BufferedReader getBufferedReader() throws FileNotFoundException {
        return new BufferedReader(new FileReader(this));
    }

    public FileReader getFileReader() throws FileNotFoundException {
        return new FileReader(this);
    }

/*
    public String readLine(){
        LineNumberReader reader = null;
        String line = null;
        try {
            reader = new LineNumberReader(new FileReader(this));
            line = reader.readLine();
        } catch (FileNotFoundException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        } catch (IOException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        } finally {
            try {
                if (reader != null ) reader.close();
            } catch (IOException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            }
        }

        return line;
    }
*/

    public String getContent() {
        FileInputStream fis = null;
        String str = null;
        try {
            fis = new FileInputStream(this);
            int size = fis.available();
            byte[] bytes = new byte[size];
            fis.read(bytes);
            str = new String(bytes);
        } catch (IOException e) {
            e.printStackTrace();  //To change body of catch statement use File | Settings | File Templates.
        } finally {
            try {
                fis.close();
            } catch (IOException e) {
            }
        }
        return str;
    }

    public static void main(String[] args) {
        String path = "c:/1/2/3/Test.txt";
        TextFile txt = new TextFile(path, true);
        //TextFile txt = new TextFile("c:/1/2/3/Test.txt");

        txt.println("Text File test!", false);//Overwrite (do not append)
        txt.println("Appended line!");//append line
        txt.print("--------------");//append line

        System.out.println(new TextFile(path).getContent());
        try {
            LineNumberReader reader = txt.getLineNumberReader();
            int lineNum = 4;
            reader.setLineNumber(lineNum);
            String line = reader.readLine();

            //Always reads first line regardles
            //which line number has been set!!!!!!!!!!!!!!!!!
            System.out.println("Line (" + lineNum + ") : " + line);
            reader.close();
        } catch (FileNotFoundException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        } catch (IOException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }

    }
}

///////////////////////////////////////////////////////////////////
//NodeIterator//////////////////////////////////////////////////////
package com.jcocktail.utils.xml.dom;

import org.w3c.dom.Node;
import org.w3c.dom.NodeList;

// Depth first search of DOM Tree

public abstract class NodeIterator {
    int level = 0;

    // note use of recursion
    public void followNode(Node node) throws Exception {

        processNode(node);
        if (node.hasChildNodes()) {
            NodeList children = node.getChildNodes();
            for (int i = 0; i < children.getLength(); i++) {
                level++;
                followNode(children.item(i));
                level--;
            }
        }
        postProcessNode(node);

    }

    public int getLevel() {
        return level;
    }

    // Override this method to do something as each node is visited
    protected abstract void processNode(Node node) throws Exception;

    // I could make processNode() a separate method in
    // a NodeProcessor interface, and make followNode static
    // but I wanted to keep this example simple.
    protected abstract void postProcessNode(Node node) throws Exception;

}

//DOMPrinter/////////////////////////////////////////////////////////////////

import java.io.IOException;
import java.io.Writer;

import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.NamedNodeMap;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;

public class DOMPrinter extends NodeIterator{
	
	private Writer out;
	private String encoding = "UTF-8";
	private String lineSeparator = System.getProperty("line.separator");
	private boolean printDeclaration = true;
	private String identStr = "\t";
	
	public DOMPrinter() {
		super();
	}
	
	public DOMPrinter(Writer out) {
		super();
		this.out = out;
	}

	public String getEncoding() {
		return encoding;
	}

	public void setEncoding(String encoding) {
		this.encoding = encoding;
	}

	public boolean isPrintDeclaration() {
		return printDeclaration;
	}

	public void setPrintDeclaration(boolean printDeclaration) {
		this.printDeclaration = printDeclaration;
	}
	
	public String getIdentStr() {
		return identStr;
	}

	public void setIdentStr(String identStr) {
		this.identStr = identStr;
	}

	public String getLineSeparator() {
		return lineSeparator;
	}

	public void setLineSeparator(String lineSeparator) {
		this.lineSeparator = lineSeparator;
	}

	public void write(Writer out, Node node) throws Exception{
		if(node.getNodeType() == Node.DOCUMENT_NODE){			
			node = ((Document)node).getDocumentElement();			
		}
			
		this.out = out;
		if(printDeclaration) write("<?xml version=\"1.0\" encoding=\"" + encoding + "\"?>");
		followNode(node);
	}
	
	public String getIdent(String identVal) {
        int i = getLevel();
        StringBuffer sb = new StringBuffer("");
        while (i-- > 0) sb.append(identVal);
        return sb.toString();
    }
	
	private void write(String str) throws IOException{
		out.write(new String(str.getBytes(),encoding));		
	}
	
	public String attributesToString(Element element) {
        String retVal = "";
        NamedNodeMap attrMap = element.getAttributes();
        for (int i = 0; i < attrMap.getLength(); i++) {
            Node attr = attrMap.item(i);
            String attrName = attr.getNodeName();
            String attrValue = element.getAttribute(attrName);
            retVal = retVal + " " + attrName + "=\"" + attrValue + "\"";
        }
        return retVal;
    }
	
	public String getCDATA(Element element) {
        String txt = "";

        if (element.hasChildNodes()) {
            NodeList childNodes = element.getChildNodes();

            if (childNodes != null) {
                for (int j = 0; j < childNodes.getLength(); j++) {
                    if (childNodes.item(j) != null && childNodes.item(j).getNodeType() == Node.CDATA_SECTION_NODE) {
                        txt += childNodes.item(j).getNodeValue();
                    }
                }
            }
        }
        //else return null;
        return txt;
    }
	
	public String getTextContent(Element element) {
        String txt = "";

        if (element.hasChildNodes()) {
            NodeList childNodes = element.getChildNodes();

            if (childNodes != null) {
                for (int j = 0; j < childNodes.getLength(); j++) {
                    if (childNodes.item(j) != null && childNodes.item(j).getNodeType() == Node.TEXT_NODE) {
                        txt +=  childNodes.item(j).getNodeValue();
                    }
                }
            }
        }
        /* Replace XML special characters...
	    1.  & - &amp;
			2. < - &lt;
			3. > - &gt;
			4. " - &quot;
			5. ' - &#39; 
			
         */
        return txt.
        	replaceAll("&", "&amp;").
			replaceAll("<", "&lt;").
			replaceAll(">", "&gt;").							
			replaceAll("\"", "&quot;").
			replaceAll("'", "&#39;");
			
    }
	
	protected void processNode(Node node) throws Exception {	
		
		if(node.getNodeType() == Node.COMMENT_NODE){
			write(getIdent(identStr));
			write("<!-- ");
			write(node.getNodeValue());
			write(" -->".concat(lineSeparator));
			return;
		}
		if(node.getNodeType() != Node.ELEMENT_NODE) return;
				
		//Do not write a new line separator if 'out' is empty
		if(out.toString().trim().length()>0)write(lineSeparator);
		
		write(getIdent(identStr));
		write("<");
		write(node.getNodeName());
		
		String attributes = attributesToString((Element)node);
		if(!"".equals(attributes.trim())) write(" ");
		write(attributes);
		if (node.hasChildNodes()){
			write(">");	
			
			String text = getTextContent((Element)node);
			
			if (!"".equals(text.trim())){				
				write(text);				
			}			
			
			String cdata = getCDATA((Element)node).trim();
			if (!"".equals(cdata)){
//				write(getIdent(identStr));
				write("<![CDATA[");
				write(cdata);
				write("]]>");
			}						
		}
		else{
			write("/>");
		}
		out.flush();
		
	}

	protected void postProcessNode(Node node) throws Exception {
		if(node.getNodeType() != Node.ELEMENT_NODE) return;
		ElementAdapter ea = new ElementAdapter((Element)node);
		if (ea.getElement().hasChildNodes()){
			if ("".equals(ea.getTextAndCDATA().trim())){
				write(lineSeparator.concat(getIdent(identStr)));
			}
			write("</");
			write(ea.getElementName());
			write(">");
		}	
		out.flush();		
	}
	
	public static void main(String[] args) throws Exception {
		java.io.StringWriter w = new java.io.StringWriter();
		DOMPrinter dw = new DOMPrinter(w);
		dw.setPrintDeclaration(false);
		Document d = BasicDom.parseXml("<root>\n" +
				"\t<firstChild attrib1=\"ATTRIB1\">TEXT1--</firstChild>" +
				"<secondChild >TTTasdf\n<![CDATA[**sdfsdf**]]>sdasdfsdaf</secondChild>" +
				"</root>", null, false);
		dw.write(w,d);
		System.out.println(w);
	}
}
//BasicDom//////////////////////////////////////////////////////////////////

import java.io.File;
import java.io.IOException;
import java.io.StringReader;
import java.io.StringWriter;
import java.io.Writer;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.transform.Result;
import javax.xml.transform.Source;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerConfigurationException;
import javax.xml.transform.TransformerException;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;

import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.xml.sax.InputSource;
import org.xml.sax.SAXException;

import com.jcocktail.utils.data.Table;
import com.jcocktail.utils.data.TableUtils;

public class BasicDom {

    // Parses an XML file and returns a DOM document.
    // If validating is true, the contents is validated against the DTD
    // specified in the file.
    public static synchronized Document parseXmlFile(String filename, boolean validating) throws ParserConfigurationException, IOException, SAXException {
        //try {
        // Create a builder factory
        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
        factory.setValidating(validating);

        // Create the builder and parse the file
        Document doc = factory.newDocumentBuilder().parse(new File(filename));
        return doc;
        //} catch (SAXException e) {
        // A parsing error occurred; the xml input is not valid
        //} catch (ParserConfigurationException e) {
        //} catch (IOException e) {
        //}
        //return null;
    }

    /**
     * @param s
     * @param systemId
     * @param validating
     * @return
     */
    public static synchronized Document parseXml(String s, String systemId, boolean validating) {
        InputSource is = new InputSource();
        is.setCharacterStream(new StringReader(s));

        if (systemId != null || "".equals(systemId)) is.setSystemId(systemId);

        try {

            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
            DocumentBuilder builder = factory.newDocumentBuilder();
            factory.setValidating(validating);

            Document doc = builder.parse(is);
            return doc;
        } catch (SAXException sxe) {
            // Error generated during parsing)
            Exception x = sxe;
            if (sxe.getException() != null)
                x = sxe.getException();
            x.printStackTrace();

        } catch (ParserConfigurationException pce) {
            // Parser with specified options can't be built
            pce.printStackTrace();

        } catch (IOException ioe) {
            // I/O error
            ioe.printStackTrace();
        }
        return null;
    }

    public static String writeXml(Document doc) {
    	String xml = null;
    	StringWriter out = new StringWriter();
    	writeXml(doc,new StreamResult(new StringWriter()));
    	xml = out.toString();
    	return xml;
    }
    
//  This method writes a DOM document to a file
    public static void writeXml(Document doc, Writer writer) {
    	writeXml(doc,new StreamResult(writer));
    }
    
    //  This method writes a DOM document to a file
    public static void writeXml(Document doc, File file) {
    	writeXml(doc,new StreamResult(file));
    }
    
    public static void writeXml(Document doc, Result result) {
        try {
            // Prepare the DOM document for writing
            Source source = new DOMSource(doc);
            // Write the DOM document to the file
            Transformer xformer = TransformerFactory.newInstance().newTransformer();
            xformer.transform(source, result);
        } catch (TransformerConfigurationException e) {
        } catch (TransformerException e) {
        }
    }

    //TODO: This method is in development. Don't use it!!!
    public static synchronized Document loadFromTable(Table elements, Table attributes) {
        try {

            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
            DocumentBuilder builder = factory.newDocumentBuilder();

            Document doc = builder.newDocument();
            Element item = iterateElementTableRows(doc, null, elements, attributes);

            System.out.println("element = " + item);
            doc.appendChild(item);
//            try {
//                Element element = null;
//                for (int i = 0; i < elements.getRowCount(); i++) {
//                    String elementId = elements.getString("ELEMENT_ID", i);
//                    String elementName = elements.getString("ELEMENT_NAME", i);
//                    String elementText = elements.getString("ELEMENT_TEXT", i);
//                    String elementParentId = elements.getString("ELEMENT_PARENT_ID", i);
//
//                    element = doc.createElement(elementName);
//
//                    Table childElements = getChildElements(elements, elementId);
//                    if (childElements != null) {
//                        for (int k = 0; k < childElements.getRowCount(); k++) {
//                            Node n = element.appendChild(doc.createElement(childElements.getString("ELEMENT_NAME", k)));
//
//                        }
//                    }
//
//                    System.out.println("childElements = " + childElements);
////                    while ((childElements = getChildElements(childElements, elementParentId)) != null){
////                        System.out.println("childElements = " + childElements);
////                    }
//
//                    element.appendChild(doc.createTextNode(elementText));
//
//                    Table attribs = TableUtils.select(attributeTable,
//                            new String[]{"ELEMENT_ID", "ATTRIB_NAME", "ATTRIB_VALUE"},
//                            new String[]{"ELEMENT_ID=" + elementId});
//
//                    if (attribs != null) {
//                        for (int j = 0; j < attribs.getRowCount(); j++) {
//                            String name = attribs.getString("ATTRIB_NAME", j);
//                            String value = attribs.getString("ATTRIB_VALUE", j);
//                            element.setAttribute(name, value);
//                        }
//                    }
//                }
//                Element menu = doc.createElement("menu");
//                menu.appendChild(element);
//                doc.appendChild(menu);
//
//            } catch (Exception e) {
//                e.printStackTrace();  //To change body of catch statement use File | Settings | File Templates.
//            }


            return doc;

        } catch (ParserConfigurationException pce) {
            // Parser with specified options can't be built
            pce.printStackTrace();

        }
        return null;
    }

    private static synchronized Element iterateElementTableRows(Document doc, Element item, Table elements, Table attributes) {
        try {
            if (elements != null) {
                for (int i = 0; i < elements.getRowCount(); i++) {
                    String elementId = elements.getString("ELEMENT_ID", i);
                    String elementName = elements.getString("ELEMENT_NAME", i);
                    String elementText = elements.getString("ELEMENT_TEXT", i);
                    String elementParentId = elements.getString("ELEMENT_PARENT_ID", i);
                    System.out.println("elementId = " + elementId);
                    Table childElements = getChildElements(elements, elementId);
                    if (item == null) {
                        item = doc.createElement(elementName);

                    } else {
                        item.appendChild(doc.createElement(elementName));
                    }

                    //Append Text Node
                    item.appendChild(doc.createTextNode(elementText));

                    //Add Attributes
                    Table attribs = getElementAttributes(attributes, elementId);
                    for (int j = 0; j < attribs.getRowCount(); j++) {
                        item.setAttribute(attribs.getString("ATTRIB_NAME", j), attribs.getString("ATTRIB_VALUE", j));
                    }


                    if (childElements != null) iterateElementTableRows(doc, item, childElements, attributes);
                }

            }
        } catch (Exception e) {
            e.printStackTrace();  //To change body of catch statement use File | Settings | File Templates.
        }
        return item;
    }

    private static synchronized Table getChildElements(Table elements, String elementId) {
        Table childElements = TableUtils.select(elements,
                new String[]{"ELEMENT_ID", "ELEMENT_NAME", "ELEMENT_TEXT", "ELEMENT_PARENT_ID"},
                new String[]{"ELEMENT_PARENT_ID=" + elementId});
        return childElements;
    }

    private static synchronized Table getElementAttributes(Table attributes, String elementId) {
        Table childElements = TableUtils.select(attributes,
                new String[]{"ELEMENT_ID", "ATTRIB_NAME", "ATTRIB_VALUE"},
                new String[]{"ELEMENT_ID=" + elementId});
        return childElements;
    }

    public static synchronized Document createDocumentInstance() throws ParserConfigurationException {
        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
        DocumentBuilder builder = factory.newDocumentBuilder();
        // Create document instance ...
        Document documnet = builder.newDocument();
        return documnet;
    }
/*
    public static void main(String[] args) {

        //String str = FileUtils.readStringFromFile("C:\\wdir\\jLab\\DocumentMill\\src\\java\\menu1.xml");
        String str = FileUtils.readStringFromFile("c:\\wdir\\jLab\\DocumentMill\\src\\java\\resources\\table.xml");

        DomIterator di = new DomIterator(BasicDom.parseXml(str, "", false));

        Table elements = di.getElementTable();
        System.out.println("elements = " + elements);

        Table attributes = di.getAttributeTable();
        System.out.println("attributes = " + attributes);

        Document doc = BasicDom.loadFromTable(elements, attributes);
        System.out.println("doc = " + doc.getDocumentElement());
    }
    */
}
//ElementAdapter//////////////////////////////////////////////////////////////////

import java.io.Serializable;

import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.NamedNodeMap;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;

public class ElementAdapter implements Serializable{
    private Element element;
    private int id = 0;
    private int parentId = -1;
    private int level = 0;
    private String identVal = "\t";


    public ElementAdapter(Element element) {
        this.element = element;
        setLevel();
    }

    public ElementAdapter(Element element, int id, int parentId) {
        this.element = element;
        this.id = id;
        this.parentId = parentId;
        setLevel();
    }

    public ElementAdapter(Element element, int id) {
        this.element = element;
        this.id = id;        
        setLevel();
    }
    
    public int getId() {
        return id;
    }

    public int getParentId() {
        return parentId;
    }

    public Element getElement() {
        return element;
    }

    public Document getOwnerDocument() {
        return element.getOwnerDocument();
    }
    
    public String getElementName() {
        return element.getNodeName();
    }

    public void setElement(Element element) {
        this.element = element;
    }

    public String getCDATA() {
        String txt = "";

        if (element.hasChildNodes()) {
            NodeList childNodes = element.getChildNodes();

            if (childNodes != null) {
                for (int j = 0; j < childNodes.getLength(); j++) {
                    if (childNodes.item(j) != null && childNodes.item(j).getNodeType() == Node.CDATA_SECTION_NODE) {
                        txt += childNodes.item(j).getNodeValue();
                    }
                }
            }
        }
        //else return null;
        return txt;
    }

    public String getText() {
        String txt = "";

        if (element.hasChildNodes()) {
            NodeList childNodes = element.getChildNodes();

            if (childNodes != null) {
                for (int j = 0; j < childNodes.getLength(); j++) {
                    if (childNodes.item(j) != null && childNodes.item(j).getNodeType() == Node.TEXT_NODE) {
                        txt +=  childNodes.item(j).getNodeValue();
                    }
                }
            }
        }
        //else return null;
        return txt;
    }

    public String getTextAndCDATA() {
        String txt = "";

        if (element.hasChildNodes()) {
            NodeList childNodes = element.getChildNodes();

            if (childNodes != null) {
                for (int j = 0; j < childNodes.getLength(); j++) {
                    if (childNodes.item(j) != null && childNodes.item(j).getNodeType() == Node.CDATA_SECTION_NODE ) {
                        txt += childNodes.item(j).getNodeValue();
                    }
                    
                    if (childNodes.item(j) != null && childNodes.item(j).getNodeType() == Node.TEXT_NODE ) {
                        txt += childNodes.item(j).getNodeValue();                     
                    }
                }
            }
        }
        //else return null;
        return txt;
    }

    public String getAttrVal(String name) {
        return element.getAttribute(name);
    }

    public int getLevel() {

        return level;
    }

    public void setLevel() {

        Node temp = element;
        if (temp == null) return;
        while ((temp = temp.getParentNode()) != null) {
            if (temp.getNodeType() == Node.ELEMENT_NODE) level++;
        }

    }

    public String getIdentVal() {
        return identVal;
    }

    public void setIdentVal(String identVal) {
        this.identVal = identVal;
    }
//
//    public String getPath() {
//        String retVal = "/" + element.getNodeName();
//        Node temp = element;
//        if (temp == null) return "";
//        while ((temp = temp.getParentNode()) != null) {
//            if (temp.getNodeType() == Node.ELEMENT_NODE)
//                retVal = "/" + temp.getNodeName() + retVal;
//        }
//        return retVal;
//    }

    public String getXPath() {
        String retVal = "/" + element.getNodeName() + "[" + getElementSiblingIndex(element) + "]";
        Node temp = element;
        if (temp == null) return "";
        while ((temp = temp.getParentNode()) != null) {
            if (temp.getNodeType() == Node.ELEMENT_NODE)
                retVal = "/" + temp.getNodeName() + "[" + getElementSiblingIndex((Element) temp) + "]" + retVal;
        }
        return retVal;
    }

    public int getElementSiblingIndex(Element e) {
        Node sibling = e.getPreviousSibling();
        int elementIdx = 1;

        while (sibling != null) {
            if (sibling.getNodeType() == Node.ELEMENT_NODE && sibling.getNodeName().equals(e.getNodeName())) {
                elementIdx++;
            }
            sibling = sibling.getPreviousSibling();
        }
        return elementIdx;
    }

    public String attributesToString() {
        String retVal = "";
        NamedNodeMap attrMap = element.getAttributes();
        for (int i = 0; i < attrMap.getLength(); i++) {
            Node attr = attrMap.item(i);
            String attrName = attr.getNodeName();
            String attrValue = getAttrVal(attrName);
            retVal = retVal + attrName + "=\"" + attrValue + "\" ";
        }
        return retVal;
    }

    public String getIdent() {
        int i = getLevel();
        StringBuffer sb = new StringBuffer("");
        while (i-- > 0) sb.append(identVal);
        return sb.toString();
    }

    public String toString() {
        return "ElementAdapter{" +
                "element=" + element +
                ", id=" + id +
                ", parentId=" + parentId +
                "}";
    }
    

//    public static String encode(String str){
//    	return str.replaceAll("<","&lt;").replaceAll(">","&gt;").replaceAll("\"","&quot;");
//    }
    
//    public static String decode(String str){
//    	return str.replaceAll("&lt;","<").replaceAll("&gt;",">").replaceAll("&quot;","\"");
//    }
}
///////////////////////////////////////////////////////////////////

import java.util.Hashtable;

import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.NamedNodeMap;
import org.w3c.dom.Node;

import com.jcocktail.utils.file.TextFile;

public class NodeToHTMLTable extends NodeIterator {

    StringBuffer sb = new StringBuffer();
    int eId = 0;
    int eIdx = 1;
    //String currentElementName ="";
    String lastElementName = "";

    Hashtable elementMap = new Hashtable();
    
    boolean showFileData=false;
    

    public boolean isShowFileData() {
		return showFileData;
	}

	public void setShowFileData(boolean showFileData) {
		this.showFileData = showFileData;
	}

	public NodeToHTMLTable(Node n) throws Exception {
        super();
        followNode(n);
    }

    public Element getElement(Object key) {
        return (Element) elementMap.get(key);
    }

    /* (non-Javadoc)
    * @see com.docmill.utils.xml.dom.NodeIterator#processNode(org.w3c.dom.Node)
    */
    protected void processNode(Node node) {
        if (node.getNodeType() != Node.ELEMENT_NODE) return;
        eId++;
        ElementAdapter ea = new ElementAdapter((Element) node);

        if (!lastElementName.equals(ea.getElementName())) {
            eIdx = 1;
        }
        String elementKey = String.valueOf(node.hashCode());
        elementMap.put(elementKey, (Element) node);

        //System.out.println(ea.getXPath());

        //System.out.println((eId++) + ea.getPath().replaceAll("/", "-") + "-" + eIdx++);
//        DomElemzentEvaluator eval = new DomElementEvaluator((Element) node);

//        String retVal = null;
//        try {
//            retVal = eval.evalExp("${IDENT}<${NAME} ${ATTRIB_LIST}>${TEXT_CDATA}");
//        } catch (Exception e) {
//            e.printStackTrace();  //To change body of catch statement use File | Settings | File Templates.
//        }
//        System.out.println(retVal);

//        sb.append("\n").append(ea.getIdent()).append("<TABLE border=\"1\" bordercolor=\"#9BB5D0\" width=\"100%\" cellspacing=\"0\" cellpadding=\"2\"><TR><TD width=\"5\" bgcolor=\"#E2AAAA\" align=\"center\" valign=\"top\" rowspan=\"2\">-</TD><TD bgcolor=\"#E2DEDC\" valign=\"top\"><I><B>").
//                append(ea.getElementName()).append("</B></I></TD><TD>").append(getAttributeHTMLTableV2(ea)).append(
//                "</TD></TR><TR><TD colspan=\"2\">");
        sb.
                append("<font color=\"003399\" face=\"Arial, Helvetica\" size=2>\n").
                append("\t\t<a id=\"xCell_").append(eId).append("\" style=\"CURSOR: auto;\" onclick=\"ShowHide('Cell_").append(eId).
                append("');\" href=\"#xCell_").append(eId).append("\" >\n").
                append("\t\t\t<font face=Arial,helvetica color=#aa0000 size=1><b>&gt;&gt;</b></font>\n").
                append("\t\t</a>\n").
                append("\t\t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n").
                append("\t\t<a href=\"DirectoryDetail.jsp?perform=Update&RECORD_ID=").append(eId).append(
                "\"><font face=\"Arial,helvetica\" color=\"#aa0000\" size=\"1\">edit</font></a>&nbsp;\n").
                append("\t\t<a href=\"DirectoryDetail.jsp?perform=Print&elementKey=").append(elementKey).append(
                "\"><font face=\"Arial,helvetica\" color=\"#aa0000\" size=\"1\">print</font></a>&nbsp;\n").
                append("\t\t<a href=\"javascript:openThis('PrintNode.jsp?elementKey=").append(elementKey).append(
                "','card',376,264,(screen.availWidth/2 - 376/2),(screen.availHeight/2 - 240/2))\"><font face=\"Arial,helvetica\" color=\"#aa0000\" size=\"1\">print</font></a>&nbsp;\n").
                append("\t\t<fieldset>\n").
                append("\t\t<legend>\n").
                append("\t\t\t<a href=\"javascript:openThis('PrintNode.jsp?elementKey=").append(elementKey).append(
                "','card',376,264,(screen.availWidth/2 - 376/2),(screen.availHeight/2 - 240/2),'yes','yes','no')\">\n").
                append("\t\t\t\t<font face=\"Arial,helvetica\" color=\"#aa0000\" size=\"3\">\n").
                append("\t\t\t\t\t<b><i>").append(ea.getElementName()).append("</i></b>\n").append("\t\t\t\t</font>\n").
                append("\t\t\t</a>&nbsp;\n").append("\t\t</legend>\n").
                append("\t\t<div id=\"Cell_").append(eId).append("\" style=\"padding: 5px; DISPLAY: ").append(getLevel() > 1 ? "none" : "block").append(";\">\n").
                append("\t\t<TABLE border=\"0\" bordercolor=\"#9BB5D0\" width=\"100%\" cellspacing=\"0\" cellpadding=\"2\">\n").
                append("\t\t\t<TR>\n").
                append("\t\t\t\t<TD width=\"5\" bgcolor=\"white\" align=\"center\" valign=\"top\" rowspan=\"2\">-</TD>\n").
                append("\t\t\t\t<TD bgcolor=\"#E2DEDC\" valign=\"top\">\n").
                //append("\t\t\t\t\t<I><B>").append(ea.getElementName()).append("</B></I>\n").
                        append("\t\t\t\t</TD>\n").append("\t\t\t<TD>\n").
                append("\t\t\t\t").append(getAttributeHTMLTableV2(ea)).append("\t\t\n").
                append("\t\t\t</TD>\n").append("\t\t</TR>\n").
                append("\t\t<TR>\n").
                append("\t\t<TD colspan=\"2\">");
        lastElementName = ea.getElementName();
    }

    protected void postProcessNode(Node node) {
        if (node.getNodeType() != Node.ELEMENT_NODE) return;
        ElementAdapter ea = new ElementAdapter((Element) node);
        if (showFileData && ea.getTextAndCDATA() != null && !"".equals(ea.getTextAndCDATA().trim())) {
            sb.append("<PRE>").append(ea.getTextAndCDATA()).append("</PRE>");
        }

        ///////////////////////////////////////////////
        sb.append("\t\t</TD>\n\t</TR></TABLE>\n");
        sb.append("\t\t</div>\n").append("\t</fieldset>\n").append("</font>&nbsp;");
        ///////////////////////////////////////////////
//        DomElementEvaluator eval = new DomElementEvaluator((Element)node);
//        String retVal = null;
//        try {
//            retVal = eval.evalExp("${IDENT}</${NAME}>");
//        } catch (Exception e) {
//            e.printStackTrace();  //To change body of catch statement use File | Settings | File Templates.
//        }
//        System.out.println(retVal);
        ///////////////////////////////////////////////
    }

    private String getAttributeHTMLTableV1(ElementAdapter ea) {
        StringBuffer sb = new StringBuffer("<TABLE border=\"1\" width=\"100%\" bordercolor=\\\"white\\\" cellspacing=\"1\" cellpadding=\"2\">");
        StringBuffer names = new StringBuffer("<TR bgcolor=\"#BEC5D3\">");
        StringBuffer vals = new StringBuffer("<TR>");

        NamedNodeMap attrMap = ea.getElement().getAttributes();

        for (int i = 0; i < attrMap.getLength(); i++) {
            Node attr = attrMap.item(i);
            String attrName = attr.getNodeName();
            String attrValue = ea.getAttrVal(attrName);
            names.append("<TD>").append(attrName).append("</TD>");
            vals.append("<TD>").append(attrValue).append("</TD>");
        }
        names.append("</TR>");
        vals.append("</TR>");
        sb.append(names).append(vals);
        sb.append("</TABLE>");

        return sb.toString();
    }

    private String getAttributeHTMLTableV2(ElementAdapter ea) {
        StringBuffer sb = new StringBuffer("<TABLE border=\"0\" " +
                //"width=\"100%\" " +
                "cellspacing=\"0\" " +
                "cellpadding=\"2\">");

        NamedNodeMap attrMap = ea.getElement().getAttributes();

        for (int i = 0; i < attrMap.getLength(); i++) {

            Node attr = attrMap.item(i);
            String attrName = attr.getNodeName();
            String attrValue = ea.getAttrVal(attrName);
            sb.append("<TR bgcolor=\"#BEC5D3\"><TD width=\"5\" align=\"center\" valign=\"top\">-</TD><TD valign=\"top\"><B>").append(attrName).append("</B></TD><TD bgcolor=\"#E0E0D1\">").append(attrValue).append("</TD></TR>");

        }

        sb.append("</TABLE>");

        return sb.toString();
    }

    private String getAttributeHTMLTableV3(ElementAdapter ea) {
        StringBuffer sb = new StringBuffer("<TABLE border=\"0\" width=\"100%\" cellspacing=\"0\" cellpadding=\"2\">");

        sb.append("<TR bgcolor=\"#BEC5D3\"><TD width=\"5\" align=\"center\" valign=\"top\">-</TD><TD bgcolor=\"#E0E0D1\">").append(ea.attributesToString()).append("</TD></TR>");

        sb.append("</TABLE>");

        return sb.toString();
    }

//    public static String getJS(){
//    	//Java Script
//    	StringBuffer sb = new StringBuffer();
//    	sb.append("<script language=JavaScript>\n");
//    	sb.append("<!--\n");
//    	sb.append("\n");
//    	sb.append("function toggle(obj){\n");
//    	sb.append(" if(obj.style.display=='none')\n");
//    	sb.append("   obj.style.display='block';\n");
//    	sb.append(" else\n");
//    	sb.append("   obj.style.display='none';\n");
//    	sb.append("}\n");
//    	sb.append("\n");
//    	sb.append("function ShowHide( ref )\n");
//    	sb.append("{\n");
//    	sb.append("  var color;\n");
//    	sb.append("  //if( ref == 'Structure' )\n");
//    	sb.append("    color = 'aa0000';\n");
//    	sb.append("  //else\n");
//    	sb.append("    //color = '007733';\n");
//    	sb.append("\n");
//    	sb.append("  if (eval(ref).style.display =='none')\n");
//    	sb.append("  {\n");
//    	sb.append("     eval('x' + ref).innerHTML = '<font face=\"Arial,helvetica\" color=' + color + ' size=1><b>X</b></font>';\n");
//    	sb.append("     eval(ref).style.display ='';\n");
//    	sb.append("  }\n");
//    	sb.append("  else\n");
//    	sb.append("  {\n");
//    	sb.append("     eval('x' + ref).innerHTML = '<font face=\"Arial,helvetica\" color=' + color + ' size=1><b>&gt;&gt;</b></font>';\n");
//    	sb.append("     eval(ref).style.display ='none';\n");
//    	sb.append("  }\n");
//    	sb.append("}\n");
//    	sb.append("//-->\n");
//    	sb.append("</script>\n");
//        return sb.toString();
//    }

    public String toString() {

        sb.append("<script language=JavaScript>\n");
        sb.append("<!--\n");
        sb.append("\n");
        sb.append("function toggle(obj){\n");
        sb.append(" if(obj.style.display=='none')\n");
        sb.append("   obj.style.display='block';\n");
        sb.append(" else\n");
        sb.append("   obj.style.display='none';\n");
        sb.append("}\n");
        sb.append("\n");
        sb.append("function ShowHide( ref )\n");
        sb.append("{\n");
        sb.append("  var color;\n");
        sb.append("  //if( ref == 'Structure' )\n");
        sb.append("    color = 'aa0000';\n");
        sb.append("  //else\n");
        sb.append("    //color = '007733';\n");
        sb.append("\n");
        sb.append("  if (eval(ref).style.display =='none')\n");
        sb.append("  {\n");
        sb.append("     eval('x' + ref).innerHTML = '<font face=\"Arial,helvetica\" color=' + color + ' size=1><b>X</b></font>';\n");
        sb.append("     eval(ref).style.display ='';\n");
        sb.append("  }\n");
        sb.append("  else\n");
        sb.append("  {\n");
        sb.append("     eval('x' + ref).innerHTML = '<font face=\"Arial,helvetica\" color=' + color + ' size=1><b>&gt;&gt;</b></font>';\n");
        sb.append("     eval(ref).style.display ='none';\n");
        sb.append("  }\n");
        sb.append("}\n");
        sb.append("//-->\n");
        sb.append("</script>\n");
        return sb.toString();
    }

    public static void main(String[] args) throws Exception {
        //TextFile xmlFile = new TextFile("c:\\wdir\\DPMX\\web\\WEB-INF\\HTMLTable_DIRECTORY.xml", true);
        TextFile xmlFile = new TextFile("c:\\dev\\CDS\\doc\\design\\deliveryConfig_sample.xml", true);
        Document d = BasicDom.parseXml(xmlFile.getContent(), "", false);

        NodeToHTMLTable html = new NodeToHTMLTable(d);
        TextFile htmlFile = new TextFile("C:\\dev\\CDS\\doc\\design\\deliveryConfig_GUI_sample.html", true);
        //TextFile htmlFile = new TextFile("c:\\wdir\\DPMX\\web\\WEB-INF\\HTMLTable_DIRECTORY.XMLGUI.html", true);
        htmlFile.println("<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.0 Transitional//EN\">", false);
        htmlFile.println("<HTML>");
        htmlFile.println("<HEAD>");
        htmlFile.println("<TITLE> XML Web GUI </TITLE>");
        htmlFile.println("</HEAD>");
        htmlFile.println("<BODY>");
        htmlFile.println("<H3>Delivery Process Config Page</H3>");
        htmlFile.println("<HR width=\"100%\">");
        htmlFile.println(html.toString());
        htmlFile.println("</BODY>");
        htmlFile.println("</HTML>");

        //TextFile textFile = new TextFile("C:\\dev\\CDS\\doc\\design\\deliveryConfig_GUI_sample.html",true);
        //System.out.println(textFile.getContent());
    }
}

////////////////////////////////////////////////////////////////////
	/**
	 * REST API: /download
	 * 
	 * @param fileDetailsId
	 * @param response
	 * @throws IOException
	 */
	@RequestMapping(value = "/v1/downloadFile", method = RequestMethod.GET, produces = { "application/octet-stream" })
	public void downloadFile(@RequestParam(value = "fileDetailsId", required = true) Long fileDetailsId,
			@Context HttpServletResponse response, HttpServletRequest request) throws IOException {

		recordLogging(request, true, JsonUtil.toJson(request.getParameterMap()));
		FileDetails fileDetails1 = fileDetailsRepository.findOne(fileDetailsId);

		response.setContentLength(fileDetails1.getFileContent().length);
		response.setHeader("Content-Disposition", "attachment; filename=" + fileDetails1.getFileName());

		ServletOutputStream outStream = response.getOutputStream();
		InputStream in = new ByteArrayInputStream(fileDetails1.getFileContent());

		try {
			byte[] bbuf = new byte[1024];
			int length = 0;
			while ((in != null) && ((length = in.read(bbuf)) != -1)) {
				outStream.write(bbuf, 0, length);
			}

		} catch (Exception e) {
			recordError(request, false, e);
		} finally {
			in.close();
			outStream.flush();
		}
		recordLogging(request, false, "");
	}

	/**
	 * REST API: /upload
	 * 
	 * @param requestId
	 * @param fileTypes
	 * @param files
	 * @return
	 * @throws Exception
	 */
	@RequestMapping(value = "/v1/uploadFile", method = RequestMethod.POST)
	public @ResponseBody Boolean uploadFile(@RequestParam(value = "requestId", required = true) Long requestId,
			@RequestParam(value = "fileType", required = true) String[] fileTypes,
			@RequestParam(value = "file", required = true) MultipartFile[] files, HttpServletRequest request) throws Exception {

		if (fileTypes != null && files != null && fileTypes.length != files.length)
			throw new Exception("Number of fileType parameters and file parameters has to be the same!");

		WorkflowRequest wfr = workflowRequestRepository.findOne(requestId);
		List<FileDetails> fileDetailsList = new ArrayList<FileDetails>();
		for (int i = 0; i < files.length; i++) {
			
			try //Validate attachment files
			{
				validateFile(files[i]);

			} catch (ExceptionResponse er)
			{
				recordError(request, false, er);
				throw er;
			}
			
			FileDetails fileDetails = new FileDetails();
			fileDetails.setFileName(files[i].getOriginalFilename());
			fileDetails.setFileType(fileTypes[i]);
			fileDetails.setRequestDetails(wfr.getRequestDetails());
			fileDetails.setFileContent(files[i].getBytes());
			fileDetailsList.add(fileDetails);

		}

		fileDetailsRepository.save(fileDetailsList);

		return true;
	}



///////////////////////////////////////////////////////////////////////////////
@RequestMapping(value = "/downloadFile", method = RequestMethod.GET, produces =
	{ "application/octet-stream" })
	public void downloadFile(@RequestParam(value = "fileDetailsId", required = true) Long fileDetailsId,
			@Context HttpServletResponse response, HttpServletRequest request)
			throws IOException, RestClientException, CarpException
	{
		recordLogging(request, true, JsonUtil.toJson(request.getParameterMap()));
		
		String url = restConfig.getAccessUrl() + restConfig.getCarpservicesUri() + "/v1/downloadFile?fileDetailsId="
				+ fileDetailsId;
		LOGGER.info(url);

		HttpHeaders headers = new HttpHeaders();
		headers.setAccept(Arrays.asList(MediaType.APPLICATION_OCTET_STREAM));

		ResponseEntity<byte[]> responseEntity = getRestTemplate(request).exchange(url, HttpMethod.GET,
				new HttpEntity(headers), byte[].class, "1");

		HttpHeaders respHeaders = responseEntity.getHeaders();

		response.setContentLength(responseEntity.getBody().length);

		response.setHeader("Content-Disposition", respHeaders.get("Content-Disposition").get(0));

		ServletOutputStream outStream = response.getOutputStream();

		InputStream in = new ByteArrayInputStream(responseEntity.getBody());

		try
		{
			byte[] bbuf = new byte[1024];
			int length = 0;
			while ((in != null) && ((length = in.read(bbuf)) != -1))
			{
				outStream.write(bbuf, 0, length);
			}

			recordLogging(request, false, "");
		} catch (Exception e)
		{
			recordError(request, false, e);
			
		} finally
		{
			in.close();
			outStream.flush();
		}
	}

	/**
	 * REST API: /upload
	 * 
	 * @param requestId
	 * @param fileTypes
	 * @param files
	 * @return
	 * @throws Exception
	 */
	@RequestMapping(value = "/uploadFile", method = RequestMethod.POST)
	public @ResponseBody Boolean uploadFile(@RequestParam(value = "requestId", required = true) Long requestId,
			@RequestParam(value = "fileType", required = true) String[] fileTypes,
			@RequestParam(value = "file", required = true) MultipartFile[] files, HttpServletRequest request)
			throws Exception
	{
		recordLogging(request, true, JsonUtil.toJson(request.getParameterMap()));
		
		String url = restConfig.getAccessUrl() + restConfig.getCarpservicesUri() + "/v1/uploadFile";
		LOGGER.info(url);

		MultiValueMap<String, Object> map = new LinkedMultiValueMap<String, Object>();
		map.add("requestId", requestId);

		for ( int i = 0 ; i < fileTypes.length ; i++ )
		{
			map.add("fileType", fileTypes[i]);
		}

		for ( int i = 0 ; i < files.length ; i++ )
		{
			map.add("file", new FileMessageResource(files[i].getBytes(), files[i].getOriginalFilename()));
		}

		HttpEntity<LinkedMultiValueMap<String, Object>> requestEntity = new HttpEntity<LinkedMultiValueMap<String, Object>>(
				(LinkedMultiValueMap<String, Object>) map);
		Boolean result = getRestTemplate(request).postForObject(url, requestEntity, Boolean.class);
		result = (result == null) ? new Boolean(false) : result;
		recordLogging(request, false, JsonUtil.toJson(result));
		return result;
		

	}
	


///////////////////////////////////////////////////////////////
import org.springframework.core.io.ByteArrayResource;

/**
 * @author drapig3 - Nov. 2016
 *
 */
public class FileMessageResource extends ByteArrayResource
{

	/**
	 * The filename to be associated with the file data.
	 */
	private final String filename;

	public FileMessageResource(final byte[] byteArray, final String filename)
	{
		super(byteArray);
		this.filename = filename;
	}

	@Override
	public String getFilename()
	{

		return filename;
	}
}

////////////////////////////////////////////////////////////////////
		ServletOutputStream outStream = null;

		InputStream in = null;

		try
		{
			HttpHeaders headers = new HttpHeaders();
			headers.setAccept(Arrays.asList(MediaType.APPLICATION_OCTET_STREAM));

			ResponseEntity<byte[]> responseEntity = getRestTemplate(request).exchange(url, HttpMethod.POST,
					new HttpEntity(reportApprovedReq, headers), byte[].class, "1");

			HttpHeaders respHeaders = responseEntity.getHeaders();

			response.setContentLength(responseEntity.getBody().length);
			response.setHeader("@RequestMapping(value = "/submitDataAccessWorkflowRequest", method = RequestMethod.POST)
	public @ResponseBody ResponseEntity submitDataAccessWorkflowRequest(
			@RequestParam(value = "workflowRequest", required = true) String workflowRequestStr,
			@RequestParam(value = "piaFile", required = false) MultipartFile piaFile,
			@RequestParam(value = "otherFile4", required = false) MultipartFile otherFile4,
			@RequestParam(value = "otherFile1", required = false) MultipartFile otherFile1,
			@RequestParam(value = "otherFile2", required = false) MultipartFile otherFile2,
			@RequestParam(value = "otherFile3", required = false) MultipartFile otherFile3, HttpServletRequest request)
			throws IOException, CarpException
	{
		recordLogging(request, true, JsonUtil.toJson(request.getParameterMap()));
		
		String url = restConfig.getAccessUrl() + restConfig.getCarpservicesUri()
				+ "/v1/submitDataAccessWorkflowRequest";
		LOGGER.info(url);

		MultiValueMap<String, Object> map = new LinkedMultiValueMap<String, Object>();

		map.add("workflowRequest", workflowRequestStr);

		if ( piaFile != null )
		{
			map.add("piaFile", new FileMessageResource(piaFile.getBytes(), piaFile.getOriginalFilename()));
		}
		if ( otherFile4 != null )
		{
			map.add("otherFile4", new FileMessageResource(otherFile4.getBytes(), otherFile4.getOriginalFilename()));
		}
		if ( otherFile1 != null )
		{
			map.add("otherFile1", new FileMessageResource(otherFile1.getBytes(), otherFile1.getOriginalFilename()));
		}
		if ( otherFile2 != null )
		{
			map.add("otherFile2", new FileMessageResource(otherFile2.getBytes(), otherFile2.getOriginalFilename()));
		}
		if ( otherFile3 != null )
		{
			map.add("otherFile3", new FileMessageResource(otherFile3.getBytes(), otherFile3.getOriginalFilename()));
		}

		HttpEntity<LinkedMultiValueMap<String, Object>> requestEntity = new HttpEntity<LinkedMultiValueMap<String, Object>>(
				(LinkedMultiValueMap<String, Object>) map);

		//Boolean result =  getRestTemplate(request).postForObject(url, requestEntity, Boolean.class);
		//return result==null?new Boolean(false):result;
		ResponseEntity resp =  getRestTemplate(request).exchange(url, HttpMethod.POST, requestEntity,
				new ParameterizedTypeReference<ResponseDetails<Boolean>>()
				{
				});
		
		recordLogging(request,false,JsonUtil.toJson(resp==null?null:resp.getBody()));
		return resp;
	}Content-Disposition", respHeaders.get("Content-Disposition").get(0));

			//			response.setContentType("txt/csv");
			//			response.addHeader(name, value);

			outStream = response.getOutputStream();

			in = new ByteArrayInputStream(responseEntity.getBody());

			byte[] bbuf = new byte[1024];
			int length = 0;
			while ((in != null) && ((length = in.read(bbuf)) != -1))
			{
				outStream.write(bbuf, 0, length);
			}

		} catch (Exception e)
		{
			//	        e.printStackTrace();
		} finally
		{
			try
			{
				if ( outStream != null )
					outStream.flush();
				if ( in != null )
					in.close();
			} catch (IOException e)
			{
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		}
